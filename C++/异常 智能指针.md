# C++异常与智能指针深度指南（工程落地+大厂面试）
本文基于官方文档逻辑，聚焦**工程级实现**与**面试核心考点**，通过完整代码示例、关键场景分析、底层原理拆解，帮你彻底掌握异常处理与智能指针，满足大厂项目开发与面试要求。


## 一、C++异常处理
### 1.1 为什么需要C++异常？（C语言错误处理的痛点）
C语言传统错误处理有两大缺陷，这也是C++异常存在的核心价值：
| 处理方式       | 缺陷                                                                 | 工程痛点示例                          |
|----------------|----------------------------------------------------------------------|---------------------------------------|
| 终止程序（assert） | 用户无法接受（如内存不足直接崩溃，无挽回机会）                       | `assert(b != 0);` 除0错误直接终止程序 |
| 返回错误码     | 需手动层层传递错误码，深层函数出错时，外层需逐个检查返回值，代码冗余 | 数据库连接失败（err=1）→ 服务启动失败（返回err=1）→ main处理 |

**C++异常的优势**：出错时直接“跳”到外层捕获点，无需层层传递错误码；可携带详细错误信息（如堆栈、具体参数），便于定位问题。


### 1.2 异常的核心用法（工程必掌握）
异常处理的三要素：`throw`（抛异常）、`try`（包裹可能出错的代码）、`catch`（捕获并处理异常），需严格遵循**匹配规则**与**栈展开机制**。


#### 1.2.1 异常的抛出与捕获（基础语法）
```cpp
#include <iostream>
#include <string>
using namespace std;

// 可能抛异常的函数：除0错误时抛异常
double Division(int a, int b) {
    if (b == 0) {
        // 抛出字符串类型异常（可抛任意类型，但工程中需统一为自定义异常类）
        throw string("Division by zero!"); 
    }
    return (double)a / b;
}

void Func() {
    int len, time;
    cin >> len >> time;
    // 调用可能抛异常的函数，需放在try块中
    cout << Division(len, time) << endl;
}

int main() {
    try {
        Func(); // 保护代码：可能触发异常的调用
    }
    // 捕获特定类型异常（字符串类型）
    catch (const string& errmsg) { 
        cout << "Error: " << errmsg << endl; // 处理异常：打印错误信息
    }
    // 捕获所有未匹配的异常（兜底，避免程序崩溃）
    catch (...) { 
        cout << "Unknown exception!" << endl;
    }
    return 0;
}
```


#### 1.2.2 异常的匹配与栈展开规则（面试高频）
1. **类型匹配优先**：抛出的异常对象类型，决定了哪个`catch`会被激活（需完全匹配，除了“派生类对象可被基类捕获”）；  
2. **栈展开机制**：若`try`块内无匹配`catch`，则退出当前函数栈，继续在**调用链上层**查找，直到`main`函数：  
   - 例：`main() → Func() → Division()`，若`Division`抛异常且`Func`无`catch`，则展开到`main`的`catch`；  
   - 若`main`仍无匹配`catch`，程序直接终止（因此必须加`catch(...)`兜底）。  
3. **异常对象生命周期**：抛出的异常对象会生成**临时拷贝**，捕获后临时对象销毁（类似函数传值返回）。


#### 1.2.3 异常的重新抛出（工程关键场景）
单个`catch`可能无法完全处理异常（如仅释放资源，需外层处理错误），此时需**重新抛出**异常，传递给上层：
```cpp
void Func() {
    // 申请资源（需确保异常时不泄漏）
    int* array = new int[10]; 

    try {
        int len, time;
        cin >> len >> time;
        cout << Division(len, time) << endl; // 可能抛异常
    }
    // 捕获所有异常：先释放资源，再重新抛出
    catch (...) { 
        cout << "Release array: " << array << endl;
        delete[] array; // 关键：先释放资源，避免内存泄漏
        throw; // 重新抛出异常，让外层处理错误
    }

    // 无异常时正常释放资源
    cout << "Release array: " << array << endl;
    delete[] array;
}

int main() {
    try {
        Func();
    }
    catch (const string& errmsg) {
        cout << "Main handle error: " << errmsg << endl; // 外层处理错误
    }
    catch (...) {
        cout << "Main handle unknown error!" << endl;
    }
    return 0;
}
```


### 1.3 异常安全（工程避坑重点）
异常安全是工程中最容易踩坑的点，核心原则是**避免资源泄漏**与**对象状态完整**，需牢记3条铁律：

#### 1.3.1 构造函数：避免抛异常
构造函数负责对象初始化，若中途抛异常，对象可能处于“不完整状态”（部分成员已初始化，部分未初始化），导致资源泄漏：
```cpp
class FileReader {
public:
    FileReader(const string& filename) {
        _fp = fopen(filename.c_str(), "r"); // 第一步：打开文件
        if (_fp == nullptr) {
            // 错误：此时对象已部分构造（_fp为nullptr），但无析构（析构仅对完全构造的对象调用）
            throw string("Open file failed!"); 
        }
        _buf = new char[1024]; // 第二步：申请缓冲区
    }
    ~FileReader() {
        if (_fp) fclose(_fp); // 若构造抛异常，此析构不会执行！
        if (_buf) delete[] _buf;
    }
private:
    FILE* _fp;
    char* _buf;
};
```
**解决方案**：用RAII管理资源（如智能指针包装`FILE*`），确保异常时自动释放。


#### 1.3.2 析构函数：禁止抛异常
析构函数负责资源清理，若抛异常：
- 若当前已在处理另一个异常，程序直接终止；  
- 可能导致资源泄漏（如`fclose`未执行）。  
**结论**：析构函数内绝对不抛异常，若有潜在错误（如`fclose`失败），内部消化（记录日志）。


#### 1.3.3 用RAII保证异常安全
RAII（资源获取即初始化）是解决异常安全的核心思想（智能指针就是RAII的典型应用），原理：**用对象生命周期管理资源**（构造时获取，析构时释放）。  
例：用RAII包装文件句柄，确保异常时自动关闭：
```cpp
// RAII包装FILE*
class FileGuard {
public:
    FileGuard(FILE* fp) : _fp(fp) {}
    ~FileGuard() {
        if (_fp) {
            fclose(_fp);
            cout << "File closed!" << endl;
        }
    }
    // 禁止拷贝，避免double free
    FileGuard(const FileGuard&) = delete;
    FileGuard& operator=(const FileGuard&) = delete;
private:
    FILE* _fp;
};

// 安全的文件读取类
class FileReader {
public:
    FileReader(const string& filename) {
        _fp = fopen(filename.c_str(), "r");
        if (_fp == nullptr) {
            throw string("Open file failed!");
        }
        _guard = new FileGuard(_fp); // 用RAII管理，异常时自动关闭
        _buf = new char[1024];
    }
    ~FileReader() {
        delete[] _buf;
        delete _guard; // 触发FileGuard析构，关闭文件
    }
private:
    FILE* _fp;
    char* _buf;
    FileGuard* _guard;
};
```


### 1.4 自定义异常体系（大厂标准实践）
文档中强调：**随意抛异常会导致外层无法维护**，因此大厂都会定义一套**继承式异常体系**，所有异常继承自一个基类，外层仅需捕获基类即可。


#### 1.4.1 工程级异常体系实现
```cpp
#include <string>
#include <iostream>
using namespace std;

// 基类：所有异常的父类，提供统一的错误信息接口
class Exception {
public:
    Exception(const string& errmsg, int errid) 
        : _errmsg(errmsg), _errid(errid) {}
    
    // 虚函数：支持多态，派生类可自定义错误信息格式
    virtual string what() const {
        return "Error[" + to_string(_errid) + "]: " + _errmsg;
    }

protected:
    string _errmsg; // 错误描述
    int _errid;     // 错误码（便于定位模块，如100=数据库，200=网络）
};

// 派生类1：数据库异常
class SqlException : public Exception {
public:
    // 额外携带SQL语句，便于定位错误
    SqlException(const string& errmsg, int errid, const string& sql) 
        : Exception(errmsg, errid), _sql(sql) {}
    
    // 重写what，添加SQL信息
    virtual string what() const override {
        string msg = "SqlException: ";
        msg += Exception::what(); // 复用基类逻辑
        msg += " [SQL: " + _sql + "]";
        return msg;
    }
private:
    string _sql; // 出错的SQL语句
};

// 派生类2：HTTP服务异常
class HttpException : public Exception {
public:
    // 额外携带请求类型（GET/POST）
    HttpException(const string& errmsg, int errid, const string& method) 
        : Exception(errmsg, errid), _method(method) {}
    
    virtual string what() const override {
        string msg = "HttpException: ";
        msg += Exception::what();
        msg += " [Method: " + _method + "]";
        return msg;
    }
private:
    string _method; // HTTP请求方法
};
```


#### 1.4.2 异常体系的使用（工程示例）
```cpp
// 模拟数据库操作：随机抛SQL异常
void SqlOperate() {
    srand(time(0));
    if (rand() % 3 == 0) {
        // 抛派生类异常
        throw SqlException("Permission denied", 1001, "SELECT * FROM user WHERE id=1");
    }
    cout << "SqlOperate success!" << endl;
}

// 模拟HTTP服务：调用数据库，可能抛两种异常
void HttpServer(const string& method) {
    srand(time(0));
    if (rand() % 4 == 0) {
        throw HttpException("Resource not found", 2001, method);
    }
    SqlOperate(); // 可能抛SqlException
    cout << "HttpServer success!" << endl;
}

int main() {
    while (1) {
        this_thread::sleep_for(chrono::seconds(1)); // 每秒执行一次
        try {
            HttpServer("GET"); // 可能抛HttpException或SqlException
        }
        // 捕获基类异常：多态调用what()，自动匹配派生类实现
        catch (const Exception& e) { 
            cout << e.what() << endl; // 统一处理所有异常
        }
        // 兜底：捕获未定义的异常
        catch (...) {
            cout << "Unknown exception!" << endl;
        }
    }
    return 0;
}
```
**工程优势**：  
- 外层仅需1个`catch(const Exception&)`，即可处理所有派生类异常，代码简洁；  
- 派生类可携带专属信息（如SQL、请求方法），便于定位问题；  
- 新增异常类型（如`CacheException`）时，无需修改外层捕获逻辑，符合开闭原则。


### 1.5 C++标准库异常体系（了解）
C++标准库提供了一套异常体系（定义在`<exception>`中），所有异常继承自`std::exception`，但**工程中很少直接使用**（设计不够灵活，如无法携带错误码）。

#### 1.5.1 标准库异常体系结构
```
std::exception（基类，纯虚函数what()）
├─ std::bad_alloc（new失败时抛出）
├─ std::bad_cast（dynamic_cast失败时抛出）
├─ std::bad_typeid（typeid(nullptr)时抛出）
├─ std::logic_error（逻辑错误，编译时可避免）
│  ├─ std::invalid_argument（无效参数，如atoi("abc")）
│  ├─ std::out_of_range（越界，如vector::at(10)）
│  └─ std::length_error（长度错误，如string resize(1e9)）
└─ std::runtime_error（运行时错误，编译时无法避免）
   ├─ std::range_error（范围错误，如计算结果超出范围）
   └─ std::overflow_error（溢出错误，如整数溢出）
```

#### 1.5.2 标准库异常的使用示例
```cpp
#include <exception>
#include <vector>
using namespace std;

int main() {
    try {
        // new失败抛bad_alloc
        int* p = new int[1000000000000]; 
        // vector越界抛out_of_range
        vector<int> v(5);
        v.at(10) = 10; 
    }
    catch (const bad_alloc& e) {
        cout << "bad_alloc: " << e.what() << endl;
    }
    catch (const out_of_range& e) {
        cout << "out_of_range: " << e.what() << endl;
    }
    catch (const exception& e) { // 捕获所有标准库异常
        cout << "exception: " << e.what() << endl;
    }
    return 0;
}
```


### 1.6 异常的优缺点与面试高频问题
#### 1.6.1 异常的优缺点（面试必答）
| 优点                                                                 | 缺点                                                                 |
|----------------------------------------------------------------------|----------------------------------------------------------------------|
| 1. 错误信息详细，可携带堆栈/参数，便于定位问题；                     | 1. 执行流跳转混乱，调试时难以跟踪（运行时抛异常，静态分析无法感知）； |
| 2. 无需层层传递错误码，代码简洁；                                     | 2. 有轻微性能开销（异常对象拷贝、栈展开）；                           |
| 3. 适配构造函数/运算符重载（无返回值，无法用错误码）；               | 3. 易导致资源泄漏，需配合RAII，学习成本高；                           |
| 4. 兼容第三方库（如Boost、GTest均用异常）；                           | 4. 标准库异常体系不实用，需自定义，导致体系混乱；                     |

**结论**：工程中**利大于弊**，是OO语言的标准错误处理方式，需规范使用（统一继承基类、明确异常规范）。


#### 1.6.2 面试高频问题
1. **C++异常与C语言错误码的区别？**  
   - 错误码：需手动传递，代码冗余，无法携带详细信息；  
   - 异常：自动栈展开，无需层层传递，可携带丰富信息（如SQL、堆栈），但执行流混乱。

2. **为什么构造函数不建议抛异常？析构函数禁止抛异常？**  
   - 构造函数抛异常：对象可能不完整（部分成员未初始化），析构函数不会执行，导致资源泄漏；  
   - 析构函数抛异常：若当前已在处理另一个异常，程序直接终止；且可能导致资源清理不完整（如`fclose`未执行）。

3. **异常重新抛出的场景是什么？需要注意什么？**  
   - 场景：内层仅释放资源，无法处理错误（如`Func`释放数组，`main`处理错误）；  
   - 注意：**先释放资源，再重新抛出**，避免内存泄漏。

4. **自定义异常体系的好处是什么？**  
   - 外层仅需捕获基类，即可处理所有派生类异常，代码简洁；  
   - 派生类可携带专属信息（如SQL、错误码），便于定位问题；  
   - 新增异常类型时无需修改外层逻辑，符合开闭原则。


## 二、C++智能指针
### 2.1 为什么需要智能指针？（内存泄漏的痛点）
文档中明确：C++没有垃圾回收，手动管理内存易出现**内存泄漏**与**异常安全问题**，智能指针是解决这些问题的核心工具。


#### 2.1.1 内存泄漏的场景（工程必避）
```cpp
int div() {
    int a, b;
    cin >> a >> b;
    if (b == 0) throw invalid_argument("除0错误"); // 抛异常
    return a / b;
}

void Func() {
    int* p1 = new int; // 申请资源1
    int* p2 = new int; // 申请资源2

    cout << div() << endl; // 若抛异常，下面的delete不会执行！

    delete p1; // 内存泄漏
    delete p2; // 内存泄漏
}

int main() {
    try {
        Func();
    }
    catch (const exception& e) {
        cout << e.what() << endl; // 异常处理，但p1/p2已泄漏
    }
    return 0;
}
```
**问题核心**：异常导致`delete`未执行，资源失控。智能指针的本质是**用RAII思想管理内存**，确保对象析构时自动释放资源。


#### 2.1.2 内存泄漏的危害与分类
- **危害**：长期运行的程序（如服务器、操作系统）会因内存泄漏导致响应变慢，最终卡死；  
- **分类**（工程重点关注两类）：  
  1. **堆内存泄漏**：`new/malloc`申请的内存未`delete/free`（如上述`p1/p2`）；  
  2. **系统资源泄漏**：套接字、文件句柄、互斥量等未释放（如`fopen`后未`fclose`）。


### 2.2 智能指针的核心原理：RAII+指针行为重载
智能指针本质是**封装了指针的类**，满足两大核心特性：
1. **RAII特性**：构造时获取资源（接收原始指针），析构时释放资源（`delete`原始指针）；  
2. **指针行为**：重载`operator*`和`operator->`，使其像原生指针一样使用。


#### 2.2.1 基础智能指针模拟实现（理解原理）
```cpp
#include <iostream>
using namespace std;

template<class T>
class SmartPtr {
public:
    // 构造：获取资源（接收原始指针）
    SmartPtr(T* ptr = nullptr) : _ptr(ptr) {}

    // 析构：释放资源（自动调用，避免泄漏）
    ~SmartPtr() {
        if (_ptr) {
            cout << "Delete: " << _ptr << endl;
            delete _ptr; // 释放内存
            _ptr = nullptr;
        }
    }

    // 重载*：支持解引用（如*sp = 10）
    T& operator*() { return *_ptr; }

    // 重载->：支持访问成员（如sp->year = 2024）
    T* operator->() { return _ptr; }

    // 禁止拷贝：避免double free（后续讲unique_ptr时详细说）
    SmartPtr(const SmartPtr<T>&) = delete;
    SmartPtr<T>& operator=(const SmartPtr<T>&) = delete;

private:
    T* _ptr; // 管理的原始指针
};

// 测试：异常时自动释放
struct Date { int year, month, day; };

int div() {
    int a, b;
    cin >> a >> b;
    if (b == 0) throw invalid_argument("除0错误");
    return a / b;
}

void Func() {
    SmartPtr<int> sp1(new int);       // 管理int
    SmartPtr<Date> sp2(new Date);     // 管理自定义类型

    *sp1 = 10;                        // 解引用赋值
    sp2->year = 2024;                 // 访问成员
    cout << *sp1 << " " << sp2->year << endl;

    cout << div() << endl; // 若抛异常，sp1/sp2析构时自动释放
}

int main() {
    try {
        Func();
    }
    catch (const exception& e) {
        cout << e.what() << endl; // 异常处理，sp1/sp2已自动释放
    }
    return 0;
}
```


### 2.3 C++标准智能指针（工程实战）
C++标准库提供了4种智能指针，核心区别在于**所有权管理**，需根据场景选择：
| 智能指针       | 所有权管理                     | 适用场景                     | 文档地位       |
|----------------|--------------------------------|------------------------------|----------------|
| `auto_ptr`     | 管理权转移（已废弃）           | 无（工程禁用）               | C++98（失败设计） |
| `unique_ptr`   | 独占所有权（禁止拷贝）         | 单个对象管理（如局部指针）   | C++11（推荐）   |
| `shared_ptr`   | 共享所有权（引用计数）         | 多个对象共享资源（如多线程） | C++11（核心）   |
| `weak_ptr`     | 不拥有所有权（辅助shared_ptr） | 解决shared_ptr循环引用       | C++11（辅助）   |


#### 2.3.1 `auto_ptr`：已废弃的失败设计（面试了解）
`auto_ptr`通过**管理权转移**实现拷贝，但会导致原指针“悬空”（访问时崩溃），工程中绝对禁用：
```cpp
#include <memory> // 智能指针头文件

int main() {
    auto_ptr<int> sp1(new int(10));
    auto_ptr<int> sp2(sp1); // 管理权转移：sp1的_ptr置空，sp2拥有资源

    *sp2 = 20; // 正常
    cout << *sp2 << endl; // 输出20

    *sp1 = 30; // 错误：sp1已悬空（_ptr为nullptr），访问崩溃
    return 0;
}
```
**面试考点**：`auto_ptr`的缺陷是什么？  
- 拷贝后原指针悬空，易导致访问非法内存；  
- 无法用于容器（容器拷贝时会触发管理权转移，导致元素悬空）。


#### 2.3.2 `unique_ptr`：独占所有权（工程首选）
`unique_ptr`通过**禁止拷贝**（删除拷贝构造和赋值重载）解决`auto_ptr`的问题，是“单个对象管理”的首选。

##### 1. 基本用法
```cpp
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> sp1(new int(10)); // 独占资源
    // unique_ptr<int> sp2(sp1); // 编译错误：拷贝构造已删除
    // sp1 = sp2; // 编译错误：赋值重载已删除

    // 允许移动构造/赋值（所有权转移，原指针失效）
    unique_ptr<int> sp3(move(sp1)); // 移动后sp1为空，sp3拥有资源
    *sp3 = 20;
    cout << *sp3 << endl; // 输出20

    // 管理自定义类型
    unique_ptr<Date> sp4(new Date{2024, 5, 20});
    cout << sp4->year << endl; // 输出2024

    return 0; // sp3/sp4析构时自动释放
}
```

##### 2. 工程场景：管理动态数组与自定义删除器
`unique_ptr`默认用`delete`释放资源，若管理动态数组或系统资源（如`malloc`、文件句柄），需指定**自定义删除器**：
```cpp
int main() {
    // 1. 管理动态数组：需指定删除器（delete[]）
    unique_ptr<int[], void(*)(int*)> sp1(
        new int[10], 
        [](int* ptr) { delete[] ptr; cout << "Delete array: " << ptr << endl; }
    );

    // 2. 管理malloc内存：删除器用free
    unique_ptr<int, void(*)(int*)> sp2(
        (int*)malloc(4), 
        [](int* ptr) { free(ptr); cout << "Free: " << ptr << endl; }
    );

    // 3. 管理文件句柄：删除器用fclose
    unique_ptr<FILE, void(*)(FILE*)> sp3(
        fopen("test.txt", "w"), 
        [](FILE* fp) { fclose(fp); cout << "Close file!" << endl; }
    );

    return 0;
}
```


#### 2.3.3 `shared_ptr`：共享所有权（核心，面试重点）
`shared_ptr`通过**引用计数**实现资源共享：多个`shared_ptr`指向同一资源，引用计数为0时释放资源，是工程中最常用的智能指针。

##### 1. 核心原理
- 每个`shared_ptr`内部维护两个指针：  
  1. `_ptr`：指向管理的资源；  
  2. `_pRefCount`：指向引用计数（int类型，堆上分配，所有共享对象共享）；  
- 操作规则：  
  - 拷贝构造/赋值：引用计数+1；  
  - 析构：引用计数-1，若为0则释放资源和引用计数。

##### 2. 模拟实现（理解引用计数）
```cpp
#include <mutex> // 互斥锁头文件
using namespace std;

template<class T>
class shared_ptr {
public:
    // 构造：初始化资源和引用计数（计数初始为1）
    shared_ptr(T* ptr = nullptr) 
        : _ptr(ptr)
        , _pRefCount(new int(1))
        , _pmtx(new mutex) {} // 锁：保证引用计数线程安全

    // 拷贝构造：共享资源，计数+1
    shared_ptr(const shared_ptr<T>& sp) 
        : _ptr(sp._ptr)
        , _pRefCount(sp._pRefCount)
        , _pmtx(sp._pmtx) {
        AddRef(); // 计数+1（加锁保护）
    }

    // 赋值重载：释放当前资源，共享新资源
    shared_ptr<T>& operator=(const shared_ptr<T>& sp) {
        // 避免自赋值（若当前资源与sp相同，无需操作）
        if (_ptr != sp._ptr) {
            Release(); // 释放当前资源（计数-1，可能释放资源）
            // 共享sp的资源
            _ptr = sp._ptr;
            _pRefCount = sp._pRefCount;
            _pmtx = sp._pmtx;
            AddRef(); // 计数+1
        }
        return *this;
    }

    // 析构：释放资源（计数-1）
    ~shared_ptr() {
        Release();
    }

    // 指针行为：解引用和访问成员
    T& operator*() { return *_ptr; }
    T* operator->() { return _ptr; }
    T* get() const { return _ptr; } // 获取原始指针

    // 获取引用计数
    int use_count() const { return *_pRefCount; }

private:
    // 引用计数+1（加锁，线程安全）
    void AddRef() {
        _pmtx->lock();
        (*_pRefCount)++;
        _pmtx->unlock();
    }

    // 引用计数-1（加锁，线程安全）
    void Release() {
        _pmtx->lock();
        bool needDelete = false;
        // 计数-1后为0，需释放资源和计数
        if (--(*_pRefCount) == 0 && _ptr) {
            delete _ptr;
            delete _pRefCount;
            needDelete = true;
        }
        _pmtx->unlock();

        // 释放锁（避免锁被提前释放）
        if (needDelete) {
            delete _pmtx;
        }
    }

private:
    T* _ptr;          // 管理的原始指针
    int* _pRefCount;  // 引用计数（堆上分配，共享）
    mutex* _pmtx;     // 互斥锁（保证计数线程安全）
};
```

##### 3. 工程用法（标准库`shared_ptr`）
```cpp
#include <memory>
#include <thread>
using namespace std;

// 测试shared_ptr共享资源
void ThreadFunc(shared_ptr<int>& sp, int n) {
    for (int i = 0; i < n; ++i) {
        // 拷贝shared_ptr：引用计数+1（线程安全）
        shared_ptr<int> copy(sp);
        (*copy)++; // 访问资源（需加锁，资源本身非线程安全）
    }
}

int main() {
    shared_ptr<int> sp(new int(0));
    cout << "Initial count: " << sp.use_count() << endl; // 输出1

    // 多线程共享sp
    const int n = 10000;
    thread t1(ThreadFunc, ref(sp), n);
    thread t2(ThreadFunc, ref(sp), n);
    t1.join();
    t2.join();

    cout << "Final value: " << *sp << endl; // 输出20000（需确保资源访问线程安全）
    cout << "Final count: " << sp.use_count() << endl; // 输出1
    return 0;
}
```


#### 2.3.4 `shared_ptr`的循环引用（面试核心痛点）
`shared_ptr`的最大问题是**循环引用**：两个`shared_ptr`互相指向对方，导致引用计数无法减到0，资源永久泄漏。


##### 1. 循环引用场景（链表节点示例）
```cpp
#include <memory>
using namespace std;

struct ListNode {
    int _data;
    // 问题：_prev和_next是shared_ptr，互相引用
    shared_ptr<ListNode> _prev;
    shared_ptr<ListNode> _next;

    ~ListNode() { cout << "~ListNode()" << endl; } // 不会执行，资源泄漏
};

int main() {
    shared_ptr<ListNode> node1(new ListNode);
    shared_ptr<ListNode> node2(new ListNode);
    cout << node1.use_count() << endl; // 输出1
    cout << node2.use_count() << endl; // 输出1

    node1->_next = node2; // node2计数+1 → 2
    node2->_prev = node1; // node1计数+1 → 2

    cout << node1.use_count() << endl; // 输出2
    cout << node2.use_count() << endl; // 输出2

    return 0; // node1/node2析构，计数减到1，资源未释放（泄漏）
}
```
**循环引用分析**：  
- `node1`析构：`node1`的计数从2→1（`node2->_prev`仍指向`node1`）；  
- `node2`析构：`node2`的计数从2→1（`node1->_next`仍指向`node2`）；  
- 最终两个节点的计数均为1，无法释放，导致内存泄漏。


##### 2. 解决方案：`weak_ptr`（不拥有所有权）
`weak_ptr`是`shared_ptr`的辅助工具，**不拥有资源所有权**（引用计数不增加），仅用于观察资源，可解决循环引用：
```cpp
struct ListNode {
    int _data;
    // 关键：用weak_ptr替代shared_ptr，不增加引用计数
    weak_ptr<ListNode> _prev;
    weak_ptr<ListNode> _next;

    ~ListNode() { cout << "~ListNode()" << endl; } // 会执行，资源释放
};

int main() {
    shared_ptr<ListNode> node1(new ListNode);
    shared_ptr<ListNode> node2(new ListNode);
    cout << node1.use_count() << endl; // 输出1
    cout << node2.use_count() << endl; // 输出1

    node1->_next = node2; // weak_ptr赋值，node2计数仍为1
    node2->_prev = node1; // weak_ptr赋值，node1计数仍为1

    cout << node1.use_count() << endl; // 输出1
    cout << node2.use_count() << endl; // 输出1

    return 0; // node1/node2析构，计数减到0，资源释放
}
```
**`weak_ptr`核心特性**：  
- 无`operator*`和`operator->`，需通过`lock()`获取`shared_ptr`后才能访问资源（避免资源已释放）；  
- 不影响引用计数，仅用于“观察”共享资源，解决循环引用。


#### 2.3.5 `shared_ptr`的删除器（工程扩展）
`shared_ptr`支持自定义删除器，用于管理非`new`资源（如`malloc`、文件句柄、数组）：
```cpp
#include <memory>
#include <cstdio>
using namespace std;

// 1. 管理malloc内存（删除器用free）
void FreeFunc(int* ptr) {
    free(ptr);
    cout << "Free: " << ptr << endl;
}

// 2. 管理文件句柄（删除器用fclose）
struct FileDeleter {
    void operator()(FILE* fp) {
        fclose(fp);
        cout << "Close file!" << endl;
    }
};

int main() {
    // 方式1：函数指针作为删除器
    shared_ptr<int> sp1((int*)malloc(4), FreeFunc);

    // 方式2：仿函数作为删除器
    shared_ptr<FILE> sp2(fopen("test.txt", "w"), FileDeleter());

    // 方式3：Lambda作为删除器（最灵活）
    shared_ptr<int> sp3(new int[10], [](int* ptr) {
        delete[] ptr;
        cout << "Delete array: " << ptr << endl;
    });

    return 0;
}
```


### 2.4 智能指针面试高频问题
1. **智能指针的核心原理是什么？**  
   - 基于RAII思想：构造时获取资源，析构时自动释放；  
   - 重载`operator*`和`operator->`，模拟原生指针行为。

2. **`auto_ptr`的缺陷是什么？为什么被废弃？**  
   - 缺陷：拷贝时转移管理权，导致原指针悬空（访问崩溃），无法用于容器；  
   - 废弃：C++11引入`unique_ptr`（禁止拷贝）替代，`auto_ptr`成为历史。

3. **`unique_ptr`和`shared_ptr`的区别？如何选择？**  
   - 所有权：`unique_ptr`独占（禁止拷贝），`shared_ptr`共享（引用计数）；  
   - 选择：单个对象管理用`unique_ptr`（高效），多个对象共享资源用`shared_ptr`（如多线程）。

4. **`shared_ptr`的循环引用是什么？如何解决？**  
   - 循环引用：两个`shared_ptr`互相指向，引用计数无法减到0，资源泄漏；  
   - 解决：将其中一个指针改为`weak_ptr`（不增加引用计数，仅观察资源）。

5. **`shared_ptr`的线程安全问题？**  
   - 引用计数线程安全：`shared_ptr`内部对引用计数的`++`/`--`加锁保护；  
   - 资源线程安全：`shared_ptr`管理的资源（如堆上int）非线程安全，需用户手动加锁（如`mutex`）。

6. **如何用智能指针管理非`new`资源（如`malloc`、文件句柄）？**  
   - 给智能指针指定**自定义删除器**（函数指针、仿函数、Lambda），在删除器中释放资源（如`free`、`fclose`）。


## 三、总结：工程与面试核心要点
| 模块           | 工程最佳实践                                  | 面试高频考点                          |
|----------------|-----------------------------------------------|---------------------------------------|
| 异常处理       | 1. 自定义继承式异常体系；<br>2. 构造/析构不抛异常；<br>3. 用RAII保证异常安全；<br>4. 加`catch(...)`兜底 | 1. 异常与错误码的区别；<br>2. 异常安全原则；<br>3. 自定义异常体系的好处；<br>4. 异常重新抛出场景 |
| 智能指针       | 1. 优先用`unique_ptr`（独占场景）；<br>2. 共享资源用`shared_ptr`；<br>3. `weak_ptr`解决循环引用；<br>4. 非`new`资源用自定义删除器 | 1. 智能指针原理（RAII+重载）；<br>2. `shared_ptr`循环引用与解决；<br>3. 智能指针线程安全；<br>4. 自定义删除器用法 |

掌握以上内容，可轻松应对大厂关于异常与智能指针的面试，同时写出高效、安全的工程代码，避免内存泄漏与异常安全问题。