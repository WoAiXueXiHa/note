[TOC]



# 1. å¼‚å¸¸

## 1.1. Cä¼ ç»Ÿå¤„ç†é”™è¯¯çš„æ–¹å¼

> 1. **ç»ˆæ­¢ç¨‹åºï¼Œå¦‚`assert`**ï¼Œç¼ºé™·ï¼šç”¨æˆ·ä½“éªŒæ„Ÿå·®ï¼Œè«åå…¶å¦™å°±ç»ˆæ­¢ç¨‹åºï¼Œéœ€è¦é‡æ–°è½½å…¥ç¨‹åº
> 2. **è¿”å›é”™è¯¯ç **ï¼Œç¼ºé™·ï¼šéœ€è¦ç¨‹åºå‘˜è‡ªå·±å»æŸ¥æ‰¾å¯¹åº”çš„é”™è¯¯ï¼Œå¤ªè¿‡çç¢

```c++
#include <cassert>
void errorC() {
	// 1. é”™è¯¯ç 
	int* arr = (int*)malloc(4 * sizeof(int));
	if (arr == NULL) {
		perror("malloc error:");
		return;
	}

	// 2. assert
	int num = 0;
	assert(num != 0);

}
```

## 1.2. C++å¼‚å¸¸æ¦‚å¿µ

å¼‚å¸¸æ˜¯ä¸€ç§å¤„ç†é”™è¯¯çš„æ–¹å¼ï¼Œ**å½“ä¸€ä¸ªå‡½æ•°å‘ç°è‡ªå·±æ— æ³•å¤„ç†çš„é”™è¯¯æ—¶å°±å¯ä»¥æŠ›å‡ºå¼‚å¸¸ï¼Œè®©å‡½æ•°ç›´æ¥çš„æˆ–é—´æ¥çš„è°ƒç”¨è€…å¤„ç†è¿™ä¸ªé”™è¯¯**

> * `throw`ï¼šç”¨æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œä¼ é€’é”™è¯¯ä¿¡æ¯
> * `catch`ï¼šç”¨æ¥æ•è·å¼‚å¸¸ï¼Œå¹¶è¿›è¡Œå¤„ç†ã€‚å¯ä»¥æœ‰å¤šä¸ª`catch`è¿›è¡Œæ•è·
> * `try`ï¼šåŒ…è£¹å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„ä»£ç 

```c++
void division(double a, double b) {
	if (b == 0)
		throw logic_error("åˆ†æ¯ä¸ºé›¶ï¼\n");
	cout << "ç»“æœ: " << a / b << endl;
}
int main() {
	try {
		division(10, 0);
	}
	catch(const logic_error& e){
		cout << "é”™è¯¯ï¼š" << e.what() << endl;
	}

	return 0;
}
```

## 1.3. å¼‚å¸¸çš„æŠ›å‡ºå’Œæ•è·

### å¼‚å¸¸çš„æŠ›å‡ºå’ŒåŒ¹é…åŸåˆ™

#### **1. å¼‚å¸¸æ˜¯é€šè¿‡æŠ›å‡ºå¯¹è±¡å¼•å‘çš„**

å¼‚å¸¸é€šè¿‡ `throw` å…³é”®å­—æŠ›å‡ºï¼ŒæŠ›å‡ºçš„å¯¹è±¡ç±»å‹å†³å®šäº†å°†è¦æ¿€æ´»å“ªä¸ª `catch` å—ã€‚

```c++
void func1() {
	throw "1111111";
}

int main() {
	try {
		func1();
	}
	catch (const char* errmsg) {
		cout << "æ•è·åˆ°çš„å¼‚å¸¸:" << errmsg << endl;
	}
}
```

* `throw`æŠ›å‡ºäº†ä¸ªå­—ç¬¦ä¸²
* `catch(const char* errmsg)`æ•è·äº†å¼‚å¸¸å¹¶è¿›è¡Œå¤„ç†ï¼Œ`catch`çš„`()`é‡Œé¢æ˜¯å¼‚å¸¸çš„ç±»å‹

#### **2. è¢«é€‰ä¸­çš„å¤„ç†ä»£ç æ˜¯è°ƒç”¨é“¾ä¸­ç¦»æŠ›å‡ºå¼‚å¸¸ä½ç½®æœ€è¿‘çš„é‚£ä¸ª**

 å¼‚å¸¸ä¼šåœ¨è°ƒç”¨æ ˆä¸­ä»å½“å‰å‡½æ•°å‘ä¸Šé€å±‚ä¼ æ’­ï¼Œç›´åˆ°æ‰¾åˆ°ä¸å¼‚å¸¸ç±»å‹åŒ¹é…çš„ `catch` å—ã€‚å¦‚æœæ‰¾åˆ°äº†åŒ¹é…çš„ `catch` å—ï¼Œå¼‚å¸¸å°±è¢«æ•è·å¹¶å¤„ç†ã€‚

```c++
void func() {
	throw out_of_range("è¶Šç•Œï¼");
}

void Func() {
	try {
		func();
	}
	catch (const out_of_range& e) {
		cout << "Func æ•è·åˆ°çš„å¼‚å¸¸:" << e.what() << endl;
	}
}

int main() {
	try {
		Func();
	}
	catch(const exception& e){
		cout << "main æ•è·åˆ°çš„å¼‚å¸¸ï¼š" << e.what() << endl;
	}

	return 0;
}
```

`func1` æŠ›å‡ºäº† `out_of_range` å¼‚å¸¸ã€‚

å¼‚å¸¸é¦–å…ˆä» `func1` å‘ `func2` ä¼ æ’­ï¼Œåœ¨ `func2` ä¸­æ‰¾åˆ°ä¸ç±»å‹åŒ¹é…çš„ `catch` å—å¹¶å¤„ç†å¼‚å¸¸ã€‚

å¦‚æœæ²¡æœ‰åœ¨ `func2` æ‰¾åˆ°åŒ¹é…çš„å¼‚å¸¸å¤„ç†ï¼Œå¼‚å¸¸ä¼šç»§ç»­ä¼ æ’­åˆ° `main`ã€‚

#### **3.å¼‚å¸¸å¯¹è±¡çš„æ‹·è´**

å½“å¼‚å¸¸è¢«æŠ›å‡ºæ—¶ï¼Œä¼šç”Ÿæˆä¸€ä¸ªå¼‚å¸¸å¯¹è±¡çš„æ‹·è´ã€‚è¿™æ˜¯å› ä¸ºæŠ›å‡ºçš„å¼‚å¸¸å¯èƒ½æ˜¯ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ï¼Œå®ƒéœ€è¦è¢«æ‹·è´åˆ°è°ƒç”¨æ ˆä¸­ï¼Œä»¥ä¾¿å¯ä»¥åœ¨ `catch` å—ä¸­è®¿é—®ã€‚

```c++
void func() {
	throw out_of_range("è¶Šç•Œï¼");
}
int main() {
	try {
		func();
	}
	catch (const exception& e) {
		cout << "exception æ•è·:" << e.what() << endl;
	}
	return 0;
}
```

å½“ `throw` æŠ›å‡ºå¼‚å¸¸æ—¶ï¼Œå¼‚å¸¸å¯¹è±¡ï¼ˆå¦‚ `out_of_range`ï¼‰ä¼šè¢«æ‹·è´åˆ° `catch` ä¸­ï¼Œç¡®ä¿å¼‚å¸¸å¯¹è±¡ä¸ä¼šä¸¢å¤±ã€‚

**4. `catch(...)`æ•è·æ‰€æœ‰ç±»å‹çš„å¼‚å¸¸**

`catch(...)` æ˜¯ä¸€ä¸ªé€šç”¨æ•è·è¯­æ³•ï¼Œå®ƒå¯ä»¥æ•è·ä»»ä½•ç±»å‹çš„å¼‚å¸¸ï¼Œä½†ç¼ºç‚¹æ˜¯ä¸çŸ¥é“å¼‚å¸¸çš„å…·ä½“ç±»å‹ã€‚

```c++
void func() {
	throw 42;  // æŠ›å‡ºæ•´æ•°ç±»å‹å¼‚å¸¸
}

int main() {
	try {
		func();
	}
	catch (...) {  // æ•è·æ‰€æœ‰å¼‚å¸¸
		std::cout << "Caught some exception" << std::endl;
	}
	return 0;
}

```

### å¼‚å¸¸æ ˆå±•å¼€åŒ¹é…åŸåˆ™

å¼‚å¸¸ä¼šæ²¿ç€å‡½æ•°è°ƒç”¨æ ˆå¸§å‘ä¸Šæœç´¢åŒ¹é…çš„`catch`ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„ä¸ºæ­¢ï¼Œå¦‚æœåœ¨æ ˆé¡¶(`main`å‡½æ•°)éƒ½æ²¡æœ‰åŒ¹é…ï¼Œç¨‹åºç»ˆæ­¢

> **1. æ£€æŸ¥æŠ›å¼‚å¸¸çš„ä½ç½®æ˜¯å¦åœ¨`try`å†…ï¼Œå¦‚æœåœ¨ `try` å—å†…æŠ›å‡ºï¼Œç¨‹åºä¼šç»§ç»­æœç´¢åŒ¹é…çš„ `catch` å—ã€‚**
>
> **2.  æ²¡æœ‰åŒ¹é…çš„ `catch` å—æ—¶ï¼Œé€€å‡ºå½“å‰å‡½æ•°æ ˆï¼Œç»§ç»­å‘ä¸Šä¼ é€’åˆ°è°ƒç”¨è¯¥å‡½æ•°çš„ä¸Šå±‚å‡½æ•°ã€‚ç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„ `catch`ã€‚**
>
> **3. å¦‚æœå¼‚å¸¸ä¼ æ’­åˆ° `main` è¿˜æ˜¯æ²¡æœ‰åŒ¹é…çš„ `catch`ï¼Œç¨‹åºä¼šç»ˆæ­¢ã€‚ **
>
> **4. å½“å¼‚å¸¸è¢«æŸä¸ª `catch` æ•è·å¹¶å¤„ç†åï¼Œç¨‹åºä¼šç»§ç»­æ‰§è¡Œ `catch` å—ä¹‹åçš„ä»£ç ã€‚ **

æ¥çœ‹è¿™æ®µä»£ç ï¼š

```c++
// æ ˆå±•å¼€
void func1() {
    throw out_of_range("Out of range error in func1");  // å¼‚å¸¸åœ¨ func1 ä¸­æŠ›å‡º
}

void func2() {
    try {
        func1();  // å¼‚å¸¸ä» func1 ä¼ é€’åˆ° func2
    }
    catch (const out_of_range& e) {
        cout << "Caught in func2: " << e.what() << endl;  // func2 æ•è·å¼‚å¸¸
        throw;  // é‡æ–°æŠ›å‡ºå¼‚å¸¸
    }
}

int main() {
    try {
        func2();  // func2 æ•è·å¼‚å¸¸å¹¶é‡æ–°æŠ›å‡º
    }
    catch (const exception& e) {
        cout << "Caught in main: " << e.what() << endl;  // main æ•è·å¼‚å¸¸å¹¶å¤„ç†
    }
    return 0;
}
```

æ¢³ç†ä¸€ä¸‹æ€è·¯ï¼š

```css
1. main() è°ƒç”¨ func2()
|
2. func2() è°ƒç”¨ func1()
|
3. func1() ä¸­æŠ›å‡º out_of_range å¼‚å¸¸
|
4. å¼‚å¸¸ä» func1() å‘ func2() ä¼ æ’­ï¼Œfunc2() æ•è·è¯¥å¼‚å¸¸
|
5. å¦‚æœ func2() ä¸­æ²¡æœ‰æ•è·å¼‚å¸¸ï¼Œå¼‚å¸¸ä¼šç»§ç»­ä¼ é€’ç»™ main() å‡½æ•°
|
6. å¦‚æœ main() æ²¡æœ‰æ•è·å¼‚å¸¸ï¼Œç¨‹åºç»ˆæ­¢

```

æ ˆå±•å¼€æ˜¯è¿™æ ·çš„ï¼š

```css
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    main()    â”‚  <-- å¼‚å¸¸ä¼šä¼ é€’åˆ° main()ï¼Œå¦‚æœæ²¡æœ‰æ•è·ç¨‹åºç»ˆæ­¢
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   func2()    â”‚  <-- å¦‚æœ func2() æ•è·å¼‚å¸¸ï¼Œæ ˆå±•å¼€åœæ­¢
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â†‘
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   func1()    â”‚  <-- å¼‚å¸¸ä» func1() æŠ›å‡ºå¹¶ä¼ é€’
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

**æ€»ç»“ï¼š**

* å¼‚å¸¸ä¼šä»æŠ›å‡ºçš„ä½ç½®å¼€å§‹æ²¿ç€è°ƒç”¨é“¾å‘ä¸Šä¼ æ’­ï¼Œç›´åˆ°æ‰¾åˆ°åŒ¹é…çš„ `catch` å—ã€‚
* å¦‚æœæ²¡æœ‰åŒ¹é…çš„ `catch`ï¼Œç¨‹åºä¼šç»ˆæ­¢ã€‚
* `catch(...)` å¯ä»¥æ•è·æ‰€æœ‰ç±»å‹çš„å¼‚å¸¸ï¼Œä½†å®ƒæ— æ³•è·å–å¼‚å¸¸çš„è¯¦ç»†ä¿¡æ¯ã€‚
* å¼‚å¸¸ä¼ æ’­è¿‡ç¨‹å«åš **æ ˆå±•å¼€**ï¼Œä»å½“å‰å‡½æ•°æ ˆä¸€ç›´ä¼ é€’åˆ°è°ƒç”¨æ ˆçš„é¡¶éƒ¨ï¼ˆ`main`ï¼‰ã€‚



## 1.4. å¼‚å¸¸çš„é‡æ–°æŠ›å‡º

å¼‚å¸¸çš„é‡æ–°æŠ›å‡ºæ˜¯æŒ‡åœ¨ **catch** å—å†…æ•è·åˆ°å¼‚å¸¸åï¼Œä¸å®Œå…¨å¤„ç†è¯¥å¼‚å¸¸ï¼Œè€Œæ˜¯å°†å…¶å†æ¬¡æŠ›å‡ºï¼Œäº¤ç»™å¤–å±‚çš„è°ƒç”¨è€…è¿›è¡Œè¿›ä¸€æ­¥å¤„ç†ã€‚

#### **ä¸ºä»€ä¹ˆéœ€è¦é‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Ÿ**

åœ¨ä¸€äº›æƒ…å†µä¸‹ï¼Œä½ å¯èƒ½å¸Œæœ›åœ¨æ•è·åˆ°å¼‚å¸¸åï¼Œåšä¸€äº›æ—¥å¿—è®°å½•ã€æ¸…ç†å·¥ä½œæˆ–è€…éƒ¨åˆ†æ¢å¤å·¥ä½œï¼Œä½†ä¸å¸Œæœ›å®Œå…¨å¤„ç†å¼‚å¸¸ã€‚é‡æ–°æŠ›å‡ºå¼‚å¸¸åï¼Œå¤–å±‚è°ƒç”¨è€…ï¼ˆé€šå¸¸æ˜¯ `main` å‡½æ•°æˆ–æ›´å¤–å±‚çš„ `catch`ï¼‰å¯ä»¥ç»§ç»­å¤„ç†è¿™ä¸ªå¼‚å¸¸ã€‚

#### **å¦‚ä½•é‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Ÿ**

åœ¨ `catch` å—ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ `throw` å…³é”®å­—é‡æ–°æŠ›å‡ºå¼‚å¸¸ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé‡æ–°æŠ›å‡ºçš„å¼‚å¸¸ç±»å‹å’ŒåŸå§‹å¼‚å¸¸ç±»å‹ä¸€è‡´ã€‚

```c++

// å¼‚å¸¸é‡æ–°æŠ›å‡º
double division(double a, double b) {
	if (0 == b) {
		throw "åˆ†æ¯ä¸ºé›¶ï¼";
	}
	return a / b;
}

void Func() {
	// å¦‚æœå‘ç”Ÿåˆ†æ¯ä¸ºé›¶æŠ›å‡ºå¼‚å¸¸ ä½†æ˜¯arrè¿˜æœªé‡Šæ”¾
	// æ‰€ä»¥è¿™é‡Œæ•è·äº†å¼‚å¸¸ä½†ä¸å¤„ç†
	// æŠŠå¼‚å¸¸äº¤ç»™å¤–ç•Œå¤„ç† æ•è·ä¹‹åé‡æ–°æŠ›å‡ºå»
	int* arr = new int[10];
	try {
		cout << division(10.1,0) << endl;
	}
	catch (...) {
		cout << "delete[]" << arr << endl;
		delete[] arr;
		throw;
	}

	cout << "delete[]" << arr << endl;
	delete[] arr;
}

int main() {

	try {
		Func();
	}
	catch (const char* errmsg) {
		cout << errmsg << endl;
	}
	return 0;
}
```

## 1.5. å¼‚å¸¸å®‰å…¨

* æ„é€ å‡½æ•°å®Œæˆå¯¹è±¡çš„æ„é€ å’Œåˆå§‹åŒ–ï¼Œä¸è¦åœ¨æ„é€ ä¸­æŠ›å¼‚å¸¸ï¼Œå¦åˆ™å¯èƒ½ä¼šå¯¼è‡´å¯¹è±¡ä¸å®Œæ•´æˆ–æ²¡æœ‰å®Œå…¨åˆå§‹åŒ–
* ææ„å‡½æ•°ä¸»è¦å®Œæˆèµ„æºæ¸…ç†ï¼Œæœ€å¥½ä¸è¦åœ¨ææ„ä¸­æŠ›å¼‚å¸¸ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´èµ„æºæ³„éœ²
* C++ä¸­ä¼šç»å¸¸å‡ºç°èµ„æºæ³„éœ²çš„é—®é¢˜ï¼Œè€ŒC++å¸¸ç”¨RAIIè§£å†³é—®é¢˜ï¼Œæˆ‘ä»¬åœ¨åæ–‡ä¸­è¯¦è§£

## 1.6. å¼‚å¸¸è§„èŒƒ

å¼‚å¸¸è§„èŒƒäºå£°æ˜å‡½æ•°å¯èƒ½æŠ›å‡ºçš„å¼‚å¸¸ç±»å‹ã€‚å®ƒçš„ä½œç”¨æ˜¯è®©å‡½æ•°çš„ä½¿ç”¨è€…äº†è§£è¯¥å‡½æ•°ä¼šæŠ›å‡ºå“ªäº›å¼‚å¸¸ç±»å‹ï¼Œä»¥åŠæ˜¯å¦æŠ›å‡ºå¼‚å¸¸ã€‚

#### **`throw()` å’Œ `noexcept` è¯­æ³•**ï¼š

* `throw()`ï¼šè¡¨ç¤ºè¯¥å‡½æ•°ä¸æŠ›å‡ºä»»ä½•å¼‚å¸¸ã€‚
* `noexcept`ï¼šè¡¨ç¤ºå‡½æ•°ä¿è¯ä¸æŠ›å‡ºå¼‚å¸¸ã€‚

```c++
// è¿™é‡Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°ä¼šæŠ›å‡ºA/B/C/Dä¸­çš„æŸç§ç±»å‹çš„å¼‚å¸¸
void fun() throw(Aï¼ŒBï¼ŒCï¼ŒD);
// è¿™é‡Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°åªä¼šæŠ›å‡ºbad_allocçš„å¼‚å¸¸
void* operator new (std::size_t size) throw (std::bad_alloc);
// è¿™é‡Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°ä¸ä¼šæŠ›å‡ºå¼‚å¸¸
void* operator delete (std::size_t size, void* ptr) throw();
// C++11 ä¸­æ–°å¢çš„noexceptï¼Œè¡¨ç¤ºä¸ä¼šæŠ›å¼‚å¸¸
thread() noexcept;
thread (thread&& x) noexcept;

```

## 1.7. å¼‚å¸¸çš„ä¼˜ç¼ºç‚¹

#### **ä¼˜ç‚¹ï¼š**

1. **é”™è¯¯åˆ†ç¦»**ï¼šå¼‚å¸¸æœºåˆ¶å°†é”™è¯¯å¤„ç†ä»æ­£å¸¸ä¸šåŠ¡é€»è¾‘ä¸­åˆ†ç¦»å‡ºæ¥ï¼Œä½¿ä»£ç æ›´ç®€æ´ã€æ›´æ˜“è¯»ã€‚
2. **è‡ªåŠ¨æ¸…ç†**ï¼šç»“åˆ RAIIï¼ˆèµ„æºè·å–å³åˆå§‹åŒ–ï¼‰åŸç†ï¼Œå¼‚å¸¸ä¼šè‡ªåŠ¨ç®¡ç†èµ„æºçš„é‡Šæ”¾ï¼Œé¿å…å†…å­˜æ³„æ¼å’Œå…¶ä»–èµ„æºæ³„æ¼ã€‚
3. **è¯¦ç»†é”™è¯¯ä¿¡æ¯**ï¼šé€šè¿‡æŠ›å‡ºå¼‚å¸¸å¯¹è±¡ï¼Œå¯ä»¥ä¼ é€’å¤§é‡çš„é”™è¯¯ä¿¡æ¯ï¼ŒåŒ…æ‹¬é”™è¯¯ç±»å‹ã€ä¸Šä¸‹æ–‡ã€å †æ ˆè·Ÿè¸ªç­‰ï¼Œæœ‰åŠ©äºè°ƒè¯•å’Œå®šä½é—®é¢˜ã€‚
4. **çµæ´»çš„é”™è¯¯å¤„ç†**ï¼šå¼‚å¸¸å¯ä»¥æ²¿ç€è°ƒç”¨æ ˆå‘ä¸Šä¼ é€’ï¼Œå…è®¸é«˜å±‚å‡½æ•°æ ¹æ®éœ€æ±‚å¤„ç†ä¸åŒç±»å‹çš„é”™è¯¯ã€‚

#### **ç¼ºç‚¹ï¼š**

1. **æ€§èƒ½å¼€é”€**ï¼šè™½ç„¶ç°ä»£ç¡¬ä»¶å·²ç»ä½¿å¾—å¼‚å¸¸å¤„ç†çš„æ€§èƒ½å¼€é”€å˜å¾—ç›¸å¯¹è¾ƒå°ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¼‚å¸¸å¤„ç†ä»ç„¶ä¼šå½±å“ç¨‹åºçš„æ€§èƒ½ï¼ˆå¦‚æ ˆå±•å¼€å’Œå¯¹è±¡æ‹·è´ï¼‰ã€‚
2. **ç¨‹åºæ§åˆ¶æµæ··ä¹±**ï¼šå¼‚å¸¸ä¼šå¯¼è‡´ç¨‹åºæ§åˆ¶æµçš„è·³è½¬ï¼Œå¯èƒ½ä½¿å¾—ä»£ç çš„æ‰§è¡Œè·¯å¾„å˜å¾—ä¸å®¹æ˜“è¿½è¸ªï¼Œå¢åŠ è°ƒè¯•çš„éš¾åº¦ã€‚
3. **ä½¿ç”¨ä¸å½“å¯èƒ½å¯¼è‡´å¤æ‚æ€§**ï¼šå¦‚æœä½¿ç”¨å¼‚å¸¸å¤„ç†ä¸å½“ï¼Œå¯èƒ½å¯¼è‡´è¿‡å¤šçš„ `try/catch` è¯­å¥ï¼Œæˆ–è€…å¼‚å¸¸æœªè¢«æ­£ç¡®æ•è·ï¼Œå¢åŠ ä»£ç å¤æ‚æ€§ã€‚



# 2. æ™ºèƒ½æŒ‡é’ˆ

## 2.1. ä¸ºä»€ä¹ˆéœ€è¦æ™ºèƒ½æŒ‡é’ˆï¼Ÿ

å…ˆæ¥çœ‹ä¸€æ®µä»£ç ï¼š

```c++
#include <iostream>
using namespace std;

double div() {
	double a = 0, b = 0;
	cin >> a >> b;
	if (0 == b) throw "åˆ†æ¯ä¸ºé›¶ !\0";
	return a / b;
} 

void funcCatch() {
	double* pa = new double;
	double* pb = new double;

	cout << div() << endl;

	delete pa;
	delete pb;
}

int main() {
	try {
		funcCatch();
	}
	catch(exception& e){
		cout << e.what() << endl;
	}

	return 0;
}
```

åˆ†æä¸€ä¸‹è¿™æ®µä»£ç çš„ç¼ºé™·ï¼š

>  **åªå¯¹åˆ†æ¯ä¸ºé›¶çš„æƒ…å†µåšäº†æŠ›å¼‚å¸¸**
>
> * å¦‚æœåˆ†æ¯ä¸ä¸ºé›¶ï¼Œ`funcCatch`æ­£å¸¸è¿è¡Œï¼Œ`pa`å’Œ`pb`æ­£å¸¸é‡Šæ”¾
> * å¦‚æœåˆ†æ¯ä¸ºé›¶ï¼Œæ¥æ”¶åˆ°`div`æŠ›å‡ºçš„å¼‚å¸¸ï¼Œç¨‹åºç»ˆæ­¢ï¼Œæ­¤æ—¶`pa`å’Œ`pb`è¿˜æœªé‡Šæ”¾ï¼Œé€ æˆå†…å­˜æ³„æ¼

æ‰€ä»¥ï¼Œæˆ‘ä»¬ä»¥å‰æ‰‹åŠ¨ç®¡ç†æŒ‡é’ˆçš„é‡Šæ”¾è¿‡äºå¤æ‚ï¼Œç¨æœ‰ä¸æ…å¿˜è®°é‡Šæ”¾å“ªä¸ªæŒ‡é’ˆéƒ½ä¼šé€ æˆå†…å­˜æ³„æ¼ï¼Œè¿™æ˜¯å¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œ

> * å†…å­˜æ³„æ¼ï¼šç”±äºç¨‹åºè®¾è®¡ä¸å½“æˆ–æ“ä½œå¤±è¯¯ï¼Œæœªèƒ½åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„å†…å­˜ç©ºé—´ã€‚å®ƒå¹¶ä¸æ„å‘³ç€å†…å­˜ç‰©ç†ä¸Šçš„æ¶ˆå¤±ï¼Œè€Œæ˜¯ç¨‹åºåœ¨åˆ†é…å†…å­˜åï¼Œå¤±å»äº†å¯¹è¿™æ®µå†…å­˜çš„æ§åˆ¶ï¼Œå¯¼è‡´å†…å­˜ç©ºé—´æ— æ³•è¢«æœ‰æ•ˆå›æ”¶ï¼Œä»è€Œé€ æˆèµ„æºæµªè´¹
> * å†…å­˜æ³„éœ²çš„å±å®³ï¼šé•¿æœŸå­˜åœ¨å†…å­˜æ³„æ¼çš„ç¨‹åºï¼Œéšç€æ—¶é—´çš„æ¨ç§»ï¼Œä¼šå¯¼è‡´å¯ç”¨å†…å­˜é€æ¸å‡å°‘ï¼Œä»è€Œå½±å“ç³»ç»Ÿæ€§èƒ½ï¼Œè¡¨ç°ä¸ºç¨‹åºå“åº”å˜æ…¢ï¼Œç”šè‡³æœ€ç»ˆå¯¼è‡´å´©æºƒæˆ–å¡æ­»çš„æƒ…å†µ

è¿™æ˜¯å†…å­˜æ³„æ¼çš„æƒ…å†µï¼š

```c++
void funcCatch() {
	double* pa = new double;
	double* pb = new double;

	cout << div() << endl;

	delete pa;
	delete pb;
}

// å†…å­˜æ³„æ¼æƒ…å†µ
void memoryLeak() {
	// 1. æŒ‡é’ˆæœªé‡Šæ”¾
	int a = 10;
	int* ptr1 = &a;

	// 2. å¼‚å¸¸é€ æˆçš„èµ„æºæœªé‡Šæ”¾
	int* arr = new int[10];
	funcCatch();

	// å…ˆæ•è·åˆ°å¼‚å¸¸ é€ æˆç¨‹åºç»ˆæ­¢ arræœªè¢«é‡Šæ”¾
	delete[] arr;
}
```

è€ŒC++11å¼•å…¥`RAIIï¼ˆResource Acquisition Is Initializationï¼‰`æœºåˆ¶ï¼Œå°±èƒ½æœ‰æ•ˆé¿å…è¿™ç§é—®é¢˜ã€‚

## 2.2. æ™ºèƒ½æŒ‡é’ˆçš„ä½¿ç”¨åŠåŸç†

### 2.2.1. RAII

RAIIï¼ˆResource Acquisition Is Initializationï¼‰**åˆ©ç”¨å¯¹è±¡å£°æ˜å‘¨æœŸæ§åˆ¶ç¨‹åºèµ„æºï¼Œåœ¨å¯¹è±¡æ„é€ æ—¶è·å–èµ„æºï¼Œåœ¨å¯¹è±¡ææ„æ—¶é‡Šæ”¾èµ„æº**ï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯ï¼š

> * æ— éœ€æ˜¾å¼é‡Šæ”¾èµ„æº
> * å¯¹è±¡æ‰€éœ€çš„èµ„æºåœ¨ç”Ÿå‘½å‘¨æœŸå†…å§‹ç»ˆä¿æŒæœ‰æ•ˆ

å®é™…ä¸Šæˆ‘ä»¬å°±æ˜¯å®šä¹‰ä¸€ä¸ªç±»æ¥æ§åˆ¶èµ„æºï¼š

```c++
template <class T>
class smartPtr {
private:
	T* _ptr;
public:
	smartPtr(T* ptr = nullptr)
		:_ptr(ptr)
	{
		cout << "smartPtræ„é€ : " << _ptr << endl;
	}

	~smartPtr() {
		if (_ptr) {
			cout << "smartPtrææ„: " << _ptr << endl;
			delete _ptr;
		}
	}
};
```

### 2.2.2. æ™ºèƒ½æŒ‡é’ˆçš„åŸç†

ä¸Šè¿°çš„`smartPtr`è¿˜ä¸èƒ½ç§°ä¹‹ä¸ºæ™ºèƒ½æŒ‡é’ˆï¼Œè¿˜ç¼ºå°‘æŒ‡é’ˆçš„è¡Œä¸ºã€‚

æŒ‡é’ˆå¯ä»¥è§£å¼•ç”¨ï¼Œå¯ä»¥é€šè¿‡`->`è®¿é—®ç©ºé—´å†…å®¹ï¼Œæ‰€ä»¥ï¼Œè¿˜éœ€é‡è½½`*`å’Œ`->`

```c++
#include <iostream>
using namespace std;

template <class T>
class smartPtr {
private:
	T* _ptr;
public:
	smartPtr(T* ptr = nullptr)
		:_ptr(ptr)
	{
		cout << "smartPtræ„é€ : " << _ptr << endl;
	}

	T& operator*() { return *_ptr; }
	T* operator->() { return _ptr; }

	~smartPtr() {
		if (_ptr) {
			cout << "smartPtrææ„: " << _ptr << endl;
			delete _ptr;
		}
	}
};

struct Date {
	int year;
	int month;
	int day;

	Date() = default;
};

int main() {
	
	smartPtr<int> sp1(new int);
	*sp1 = 10;

	smartPtr<Date> spDate(new Date);
	// è¯­æ³•ç³–ï¼š spDate->operator()->
	spDate->year = 2010;
	spDate->month = 1;
	spDate->day = 1;


	return 0;
}
```

æ™ºèƒ½æŒ‡é’ˆçš„åŸç†ï¼š

> 1. RAIIï¼šèµ„æºè·å–åŠåˆå§‹åŒ–
> 2. é‡è½½äº†`operator*`å’Œ`operator->`ï¼Œæœ‰å’ŒæŒ‡é’ˆä¸€æ ·çš„è¡Œä¸º



### 2.2.3.`auto_ptr`

`auto_ptr`æ˜¯C++98æå‡ºçš„å¤±è´¥çš„è®¾è®¡ï¼Œæ ¸å¿ƒæ˜¯ç®¡ç†æƒé™çš„è½¬ç§»ï¼ŒåŸæœ¬çš„èµ„æºç›´æ¥é‡Šæ”¾

```c++
// auto_ptr ç®¡ç†æƒé™è½¬ç§» ç¦æ­¢ä½¿ç”¨ï¼ï¼ï¼ï¼
#include <iostream>
using namespace std;

namespace autoPtr {
	template <class T>
	class auto_ptr {
	private:
		T* _ptr;
	public:
		auto_ptr(T* ptr = nullptr)
			:_ptr(ptr)
		{ 
			cout << "auto_ptræ„é€  : " << _ptr << endl;
		}

		// *this <- other otherç®¡ç†æƒç»™*this
		auto_ptr(const auto_ptr<T>& other) 
			:_ptr(other._ptr)
		{
			other._ptr = nullptr;
		}

		auto_ptr& operator=(auto_ptr<T>& other) {
			if (this != &other) {
				// å…ˆé‡Šæ”¾è‡ªå·±çš„èµ„æº
				if (_ptr) {
					delete _ptr;
				}
				// æ‹¿æ¥åˆ«äººçš„èµ„æº
				_ptr = other._ptr;
				other._ptr = nullptr;
			}
			return *this;
		}

		T& operator*() { return *_ptr; }
		T* operator->() { return _ptr; }

		~auto_ptr() {
			if (_ptr) {
				cout << "~auto_ptr() : " << _ptr << endl;
				delete _ptr;
			}
		}
	};

	struct Date {
		int year;
		int month;
		int day;

		Date() = default;
	};
}

int main() {

	autoPtr::auto_ptr<autoPtr::Date> spDate(new autoPtr::Date);
	spDate->year = 2010;
	spDate->month = 1;
	spDate->day = 1;

	autoPtr::auto_ptr<autoPtr::Date> cpDate(new autoPtr::Date);

	cpDate = spDate;

	return 0;
}
```

![auto_ptrèµ„æºæƒé™è½¬ç§»ç¤ºæ„](E:\CODE\å›¾\ç”»å›¾æˆªå›¾\auto_ptrèµ„æºæƒé™è½¬ç§»ç¤ºæ„.png)

**ğŸ™…â€å®è·µä¸­ä¸€å®šä¸èƒ½ä½¿ç”¨ğŸ™…â€**



### 2.2.4. `unique_ptr`

C++11ä½¿ç”¨ æ›´é è°±çš„`unique_ptr`ï¼š**ç®€å•ç²—æš´ç¦æ­¢æ‹·è´**

```c++
/**** uniquePtr.h ****/
#pragma once
namespace uniquePtr {
	template <class T>
	class unique_ptr {
	private:
		T* _ptr;
	public:
		unique_ptr(T* ptr = nullptr)
			:_ptr(ptr)
		{
			cout << "unique_ptræ„é€ : " << _ptr << endl;
		}

		~unique_ptr() {
			if (_ptr) {
				cout << "unique_ptrææ„: " << _ptr << endl;
			}
		}
		// ç®€å•ç²—æš´ ç¦æ­¢æ‹·è´
		unique_ptr(const unique_ptr<T>& other) = delete;
		unique_ptr& operator=(const unique_ptr<T>& other) = delete;

		T& operator*() { return *_ptr; }
		T* operator->() { return _ptr; }
	};

	struct Date {
		int year;
		int month;
		int day;

		Date() = default;
	};
}

/**** test.cpp ****/
#include <iostream>
using namespace std;
#include "uniquePtr.h"

int main() {
	uniquePtr::unique_ptr<uniquePtr::Date> upDate(new uniquePtr::Date);

	upDate->day = 0;
	upDate->month = 0;
	upDate->year = 0;

	//  error C2280: â€œuniquePtr::unique_ptr<uniquePtr::Date>::unique_ptr(const uniquePtr::unique_ptr<uniquePtr::Date> &)â€: 
	// å°è¯•å¼•ç”¨å·²åˆ é™¤çš„å‡½æ•°
	// uniquePtr::unique_ptr<uniquePtr::Date> cpDate(upDate);

	return 0;
}

```



### 2.2.5. `shared_ptr`

**`shared_ptr`çš„åŸç†ï¼šé€šè¿‡å¼•ç”¨è®¡æ•°çš„æ–¹å¼æ¥å®ç°å¤šä¸ª`shared_ptr`å¯¹è±¡ä¹‹é—´çš„èµ„æºå…±äº«**ï¼Œä¾‹å¦‚å›¾ä¹¦é¦†å€Ÿä¹¦çš„ä¾‹å­ï¼š

>  **1. å›¾ä¹¦é¦†ä¸­çš„ä¹¦**
>
> åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ**å›¾ä¹¦é¦†ä¸­çš„æ¯æœ¬ä¹¦**å°±åƒä¸€ä¸ªå¯¹è±¡ï¼Œè€Œ **ä¹¦çš„ç¼–å·**æ˜¯æŒ‡å‘è¯¥ä¹¦çš„æŒ‡é’ˆã€‚æ¯æœ¬ä¹¦çš„ç¼–å·å¯ä»¥è¢« **å¤šä¸ªå€Ÿä¹¦çš„äºº**ï¼ˆå¤šä¸ª `shared_ptr`ï¼‰æŒæœ‰ã€‚
>
>  **2. å€Ÿä¹¦çš„äºº**
>
> æ¯ä¸ªå€Ÿä¹¦çš„äººä¼šå¾—åˆ°ä¸€ä¸ª **ä¹¦çš„ç¼–å·**ï¼Œå¹¶ä¸”ä»–ä»¬å¯ä»¥ **å…±äº«è¿™æœ¬ä¹¦**ã€‚ä¾‹å¦‚ï¼Œä¸¤ä¸ªå­¦ç”Ÿå€Ÿäº†åŒä¸€æœ¬ä¹¦ï¼Œä»–ä»¬éƒ½æœ‰æŒ‡å‘è¿™æœ¬ä¹¦çš„ç¼–å·ï¼ˆå°±åƒä¸¤ä¸ª `shared_ptr` æŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡ï¼‰ã€‚
>
>  **3. å€Ÿä¹¦çš„è§„åˆ™ï¼šå¼•ç”¨è®¡æ•°**
>
> æ¯å½“æœ‰äººå€Ÿäº†è¿™æœ¬ä¹¦ï¼Œå›¾ä¹¦é¦†éƒ½ä¼šå¢åŠ ä¸€ä¸ªè®¡æ•°ï¼Œè¿™ä¸ªè®¡æ•°å°±ä»£è¡¨ **å½“å‰å€Ÿä¹¦çš„äººæ•°**ï¼ˆå°±åƒ `shared_ptr` ä¸­çš„å¼•ç”¨è®¡æ•°ï¼‰ã€‚å¦‚æœæœ‰ 2 ä¸ªäººå€Ÿäº†åŒä¸€æœ¬ä¹¦ï¼Œè®¡æ•°ä¼šæ˜¯ 2ï¼›å¦‚æœæœ‰ 3 ä¸ªäººå€Ÿäº†ï¼ŒåŒæ ·ä¼šæ˜¯ 3ã€‚
>
>  **4. å½’è¿˜ä¹¦ï¼šå‡å°‘å¼•ç”¨è®¡æ•°**
>
> å½“å€Ÿä¹¦çš„äººå½’è¿˜ä¹¦æ—¶ï¼Œå›¾ä¹¦é¦†å°±ä¼šå‡å°‘è¯¥ä¹¦çš„å€Ÿé˜…è®¡æ•°ã€‚æ¯æ¬¡æœ‰äººå½’è¿˜ä¹¦ï¼Œè®¡æ•°å°±å‡å°‘ä¸€æ¬¡ã€‚
>
> **5. æœ€åä¸€ä½å½’è¿˜ä¹¦æ—¶ï¼Œé”€æ¯ä¹¦**
>
> å½“ **æœ€åä¸€ä¸ªå€Ÿä¹¦çš„äººå½’è¿˜ä¹¦æ—¶**ï¼ˆå³å¼•ç”¨è®¡æ•°å˜ä¸º 0ï¼‰ï¼Œå›¾ä¹¦é¦†ä¼š **é”€æ¯è¿™æœ¬ä¹¦**ï¼Œè¡¨ç¤ºè¿™æœ¬ä¹¦ä¸å†è¢«éœ€è¦äº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åä¸€ä¸ª `shared_ptr` è¢«é”€æ¯æ—¶ï¼Œèµ„æºæ‰ä¼šè¢«é‡Šæ”¾ã€‚
>
> 
>
> **å¦‚ä½•ç±»æ¯”åˆ° `shared_ptr`ï¼Ÿ**
>
> 1. **æ¯æœ¬ä¹¦** ä»£è¡¨ç®¡ç†çš„ **èµ„æº**ï¼ˆæ¯”å¦‚å†…å­˜ã€æ–‡ä»¶ã€æ•°æ®åº“è¿æ¥ç­‰ï¼‰ã€‚
> 2. **å€Ÿä¹¦çš„äºº** å°±æ˜¯ **`shared_ptr` å®ä¾‹**ï¼Œæ¯ä¸ªå®ä¾‹éƒ½æ‹¥æœ‰å¯¹èµ„æºçš„å…±äº«æ‰€æœ‰æƒã€‚
> 3. **ä¹¦çš„ç¼–å·** å°±æ˜¯ `shared_ptr` ä¸­çš„ **æŒ‡é’ˆ**ã€‚
> 4. **å€Ÿä¹¦äººæ•°** å°±æ˜¯ **å¼•ç”¨è®¡æ•°**ï¼Œæ¯å½“ä¸€ä¸ª `shared_ptr` è¢«åˆ›å»ºæˆ–è€…æ‹·è´æ—¶ï¼Œå¼•ç”¨è®¡æ•°å°±å¢åŠ ï¼›å½“ä¸€ä¸ª `shared_ptr` è¢«é”€æ¯æ—¶ï¼Œå¼•ç”¨è®¡æ•°å°±å‡å°‘ã€‚
> 5. **æœ€åä¸€ä¸ªå€Ÿä¹¦çš„äººå½’è¿˜ä¹¦æ—¶**ï¼Œèµ„æºè¢«é‡Šæ”¾ï¼Œä»£è¡¨ **`shared_ptr` çš„èµ„æºé‡Šæ”¾æœºåˆ¶**ã€‚

æ¥ç®€å•å®ç°ä¸€ä¸‹ï¼š

```c++
#pragma once
#include<functional>

namespace sharedPtr {
    template <class T>
    class shared_ptr {
    private:
        T* _ptr;                  // æŒ‡å‘èµ„æºçš„æŒ‡é’ˆ
        int* _refConut;           // å¼•ç”¨è®¡æ•°æŒ‡é’ˆï¼Œè®°å½•æœ‰å¤šå°‘ä¸ª shared_ptr ç®¡ç†åŒä¸€ä¸ªèµ„æº
        // è‡ªå®šä¹‰åˆ é™¤å™¨ï¼Œå¯ä»¥åˆ é™¤ä»»æ„ç±»å‹çš„å¯¹è±¡ï¼ˆé»˜è®¤ä½¿ç”¨ deleteï¼‰
        std::function<void(T* ptr)> _del = [](T* ptr) { delete ptr; };

    public:
        shared_ptr(const T* ptr = nullptr)
            : _ptr(ptr), _refConut(new int(1))  // åˆå§‹åŒ–å¼•ç”¨è®¡æ•°ä¸º 1ï¼Œè¡¨ç¤ºèµ„æºæœ‰ä¸€ä¸ªç®¡ç†è€…
        {
            std::cout << "shared_ptræ„é€ : " << _ptr << " æ•°é‡: " << _refConut << std::endl;
        }

        // æ„é€ å‡½æ•°ï¼šä¼ å…¥è‡ªå®šä¹‰åˆ é™¤å™¨
        template <class D>
        shared_ptr(const T* ptr = nullptr, D del)
            : _ptr(ptr), _del(del), _refConut(new int(1))  // è‡ªå®šä¹‰åˆ é™¤å™¨
        {
            std::cout << "shared_ptr(const T* ptr = nullptr, D del)" << std::endl;
        }

        // æ‹·è´æ„é€ å‡½æ•°ï¼šå¢åŠ å¼•ç”¨è®¡æ•°
        shared_ptr(const shared_ptr<T>& other)
            : _ptr(other._ptr), _refConut(other._refConut)
        {
            ++(*_refConut);  // å¼•ç”¨è®¡æ•°åŠ  1
        }

        // é‡Šæ”¾èµ„æºï¼šå½“å¼•ç”¨è®¡æ•°å‡å°‘ä¸º 0 æ—¶ï¼Œé‡Šæ”¾èµ„æº
        void release() {
            if (--(*_refConut) == 0) {  
                _del(_ptr);  
                delete _refConut;  
                _ptr = nullptr;  
                _refConut = nullptr;  
            }
        }

        // èµ‹å€¼è¿ç®—ç¬¦é‡è½½ï¼šé‡Šæ”¾æ—§èµ„æºï¼Œå¢åŠ å¼•ç”¨è®¡æ•°
        shared_ptr<T>& operator=(const shared_ptr<T>& other) {
            if (this != &other) {  // é˜²æ­¢è‡ªèµ‹å€¼
                release();  
                _ptr = other._ptr;  
                _refConut = other._refConut;  
                ++(*_refConut);  
            }
            return *this;
        }

        // ææ„å‡½æ•°ï¼šè°ƒç”¨ release é‡Šæ”¾èµ„æº
        ~shared_ptr() { release(); }

        // è§£å¼•ç”¨è¿ç®—ç¬¦ï¼šè¿”å›æŒ‡å‘çš„å¯¹è±¡
        T* operator->() { return _ptr; }
        T& operator*() { return *_ptr; }

        // è·å–åŸå§‹æŒ‡é’ˆ
        T* get() { return _ptr; }

        // è·å–å½“å‰å¼•ç”¨è®¡æ•°
        int useCount() { return *_refConut; }
    };
}
```

#### `shared_ptr`è®¾è®¡é€»è¾‘

> * **èµ„æºç®¡ç†**ï¼š
>
>   * `shared_ptr` é€šè¿‡å¼•ç”¨è®¡æ•°æ¥ç®¡ç†åŠ¨æ€åˆ†é…çš„èµ„æº`_ptr`ã€‚å½“ä¸€ä¸ª `shared_ptr` è¢«åˆ›å»ºæ—¶ï¼Œèµ„æºè¢«ç®¡ç†ï¼›å½“æœ€åä¸€ä¸ª `shared_ptr` è¢«é”€æ¯æ—¶ï¼Œèµ„æºä¼šè¢«é‡Šæ”¾ã€‚
>   * `release` å‡½æ•°ç”¨äºå‡å°‘å¼•ç”¨è®¡æ•°ï¼Œå¦‚æœå¼•ç”¨è®¡æ•°å˜ä¸º 0ï¼Œåˆ™é”€æ¯èµ„æºã€‚
>
>   **å¼•ç”¨è®¡æ•°**ï¼š
>
>   * æ¯ä¸ª `shared_ptr` éƒ½æœ‰ä¸€ä¸ªæŒ‡å‘ **å¼•ç”¨è®¡æ•°**ï¼ˆ`_refConut`ï¼‰çš„æŒ‡é’ˆï¼Œç”¨æ¥è·Ÿè¸ªå½“å‰æœ‰å¤šå°‘ä¸ª `shared_ptr` å¯¹è±¡æŒ‡å‘åŒä¸€èµ„æºã€‚åˆå§‹æ—¶å¼•ç”¨è®¡æ•°ä¸º 1ï¼Œè¡¨ç¤ºåªæœ‰ä¸€ä¸ª `shared_ptr` ç®¡ç†è¯¥èµ„æºã€‚
>   * **æ‹·è´æ„é€ å‡½æ•°** å’Œ **èµ‹å€¼è¿ç®—ç¬¦** ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œè¡¨ç¤ºå¤šä¸ª `shared_ptr` å¯¹åŒä¸€èµ„æºè¿›è¡Œç®¡ç†ã€‚
>   * å½“ä¸€ä¸ª `shared_ptr` è¢«é”€æ¯æ—¶ï¼Œå¼•ç”¨è®¡æ•°ä¼šå‡å°‘ã€‚å¦‚æœå¼•ç”¨è®¡æ•°å˜ä¸º 0ï¼Œè¡¨ç¤ºæ²¡æœ‰å…¶ä»– `shared_ptr` ç®¡ç†è¯¥èµ„æºï¼Œè¿™æ—¶èµ„æºä¼šè¢«é‡Šæ”¾ã€‚
>
>   å‡è®¾æœ‰ä¸¤ä¸ª `shared_ptr`ï¼Œ`A` å’Œ `B`ï¼Œå®ƒä»¬å…±äº«åŒä¸€ä¸ªèµ„æºã€‚èµ„æºçš„å¼•ç”¨è®¡æ•°ä» 1 å¼€å§‹ï¼Œåœ¨æ¯ä¸ª `shared_ptr` åˆ›å»ºæ—¶å¢åŠ ã€‚
>
>   ```css
>    +----------------------+
>    |   shared_ptr A       |                    +-----------------------+
>    |----------------------|                    |  shared_ptr B         |
>    | _ptr  -> [Resource]  |					 | _ptr  -> [Resource]   |
>    | _refCount -> 2       |		  		     | _refCount -> 2        |
>    +----------------------+                    +-----------------------+
>           |                                            |
>           v                                            v
>       +---------+                                +---------+ 
>       | Resource| 							   | Resource| 
>       +---------+								/  +---------+
>          |								  /
>          v								/ 
>       (delete called when refCount == 0)
>   
>   ```
>
>   
>
>   **åˆ é™¤å™¨ `_del`**ï¼š
>
>   * `_del` æ˜¯ä¸€ä¸ª **å‡½æ•°å¯¹è±¡**ï¼Œé»˜è®¤ä½¿ç”¨ `delete` æ¥é‡Šæ”¾èµ„æºã€‚ä½¿ç”¨ `std::function` æ¥å®šä¹‰åˆ é™¤å™¨ï¼Œè¿™æ ·å¯ä»¥è½»æ¾æ”¯æŒè‡ªå®šä¹‰çš„èµ„æºé”€æ¯æ–¹å¼ï¼Œæ¯”å¦‚ `free` æˆ–è€…å…¶ä»–å¤æ‚çš„é”€æ¯é€»è¾‘ã€‚
>   * **è‡ªå®šä¹‰åˆ é™¤å™¨**ï¼šé€šè¿‡ä¼ å…¥ä¸åŒçš„åˆ é™¤å™¨ï¼Œæˆ‘ä»¬å¯ä»¥ç®¡ç† `new` æˆ– `malloc` åˆ†é…çš„èµ„æºï¼Œæˆ–è€…åšä¸€äº›é¢å¤–çš„æ¸…ç†æ“ä½œ
>
>   **æ‹·è´ä¸èµ‹å€¼**ï¼š
>
>   * **æ‹·è´æ„é€ å‡½æ•°**ï¼šå½“ä¸€ä¸ª `shared_ptr` è¢«æ‹·è´æ—¶ï¼Œå¼•ç”¨è®¡æ•°åŠ  1ï¼Œè¡¨ç¤ºèµ„æºè¢«å¤šä¸ª `shared_ptr` å¯¹è±¡å…±äº«ã€‚
>
>   ![æ™ºèƒ½æŒ‡é’ˆ å¼•ç”¨è®¡æ•° æ‹·è´](E:\CODE\å›¾\ç”»å›¾æˆªå›¾\æ™ºèƒ½æŒ‡é’ˆ å¼•ç”¨è®¡æ•° æ‹·è´.png)
>
>   * **èµ‹å€¼è¿ç®—ç¬¦**ï¼šåœ¨èµ‹å€¼æ—¶ï¼Œé¦–å…ˆä¼šé‡Šæ”¾æ—§èµ„æºï¼Œç„¶åå¤åˆ¶æ–°èµ„æºå¹¶å¢åŠ å¼•ç”¨è®¡æ•°ã€‚è¿™æ ·ç¡®ä¿äº† `shared_ptr` ä¹‹é—´çš„èµ„æºç®¡ç†ä¸€è‡´æ€§ã€‚
>
>   ![æ™ºèƒ½æŒ‡é’ˆ å¼•ç”¨è®¡æ•° èµ‹å€¼](E:\CODE\å›¾\ç”»å›¾æˆªå›¾\æ™ºèƒ½æŒ‡é’ˆ å¼•ç”¨è®¡æ•° èµ‹å€¼.png)

### 2.2.6. å¾ªç¯å¼•ç”¨é—®é¢˜

**å¾ªç¯å¼•ç”¨**å‘ç”Ÿåœ¨ä¸¤ä¸ªå¯¹è±¡é€šè¿‡ `shared_ptr` ç›¸äº’å¼•ç”¨ï¼Œå¯¼è‡´å®ƒä»¬çš„å¼•ç”¨è®¡æ•°æ°¸è¿œä¸ä¸º 0ï¼Œä»è€Œæ— æ³•é‡Šæ”¾èµ„æºï¼Œæœ€ç»ˆå‘ç”Ÿå†…å­˜æ³„æ¼ã€‚

å‡è®¾æœ‰ä¸ªåŒå‘é“¾è¡¨ç±»ï¼Œå®šä¹‰ä¸¤ä¸ªæˆå‘˜å˜é‡`ListNode* _prev; ListNode* _next;`ï¼Œç°åœ¨æœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼š`n1`ã€`n2`

```c++
template <class T>
struct ListNode {
    ListNode<T>* _prev = nullptr;
    ListNode<T>* _next = nullptr;

    ListNode() = default;
};

void test() {
    // åˆ›å»ºä¸¤ä¸ª ListNode<int> èŠ‚ç‚¹ï¼Œåˆ†åˆ«ç”± shared_ptr ç®¡ç†
    shared_ptr<ListNode<int>> n1(new ListNode<int>);
    shared_ptr<ListNode<int>> n2(new ListNode<int>);

    // å½¢æˆåŒå‘é“¾è¡¨å…³ç³»
    //n1->_next = n2;   // n1 æŒ‡å‘ n2
    //n2->_prev = n1;   // n2 æŒ‡å‘ n1

    // å¾ªç¯å¼•ç”¨ï¼šn1 å’Œ n2 äº’ç›¸æŒæœ‰å¯¹æ–¹çš„ shared_ptr
    // å½“ test() å‡½æ•°ç»“æŸæ—¶ï¼Œn1 å’Œ n2 çš„å¼•ç”¨è®¡æ•°æ°¸è¿œä¸ä¼šä¸º 0ï¼Œèµ„æºä¸ä¼šè¢«é‡Šæ”¾
}
```



![å¾ªç¯å¼•ç”¨](E:\CODE\å›¾\ç”»å›¾æˆªå›¾\å¾ªç¯å¼•ç”¨.png)

`n1`å’Œ`n2`ç›¸äº’ä½œç”¨ï¼ŒäºŒè€…æ— æ³•é‡Šæ”¾èµ„æºï¼Œå¯¼è‡´å†…å­˜æ³„æ¼

### 2.2.7. è§£å†³å¾ªç¯å¼•ç”¨é—®é¢˜

`weak_ptr` æ˜¯ä¸€ç§ä¸å¢åŠ å¼•ç”¨è®¡æ•°çš„æ™ºèƒ½æŒ‡é’ˆï¼Œä¸æ”¯æŒRAIIï¼Œå®ƒç”¨äºè§‚å¯Ÿ `shared_ptr` ç®¡ç†çš„èµ„æºï¼Œåœ¨`shared_ptr`èµ‹å€¼å’Œæ‹·è´çš„æ—¶å€™ï¼Œä¸å¢åŠ å¼•ç”¨è®¡æ•°

```c++
 template <class T>
    class weak_ptr {
    private:
        T* _ptr = nullptr;
    public:
        weak_ptr() = default;
        weak_ptr(const shared_ptr<T>& sp)
            :_ptr(sp._ptr)  // å°† shared_ptr çš„èµ„æºæŒ‡é’ˆ _ptr å¤åˆ¶åˆ° weak_ptr çš„ _ptr æˆå‘˜ä¸­
        {
            // è¿™é‡Œçš„æ„é€ å‡½æ•°å°†ä¸€ä¸ª shared_ptr è½¬æ¢ä¸º weak_ptrã€‚
            // weak_ptr ä¸å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå®ƒä»…ä»…è§‚å¯Ÿ shared_ptr ç®¡ç†çš„èµ„æºã€‚
            // è¿™æ ·è®¾è®¡ä½¿å¾— weak_ptr å¯ä»¥åœ¨ä¸å¹²æ‰°èµ„æºç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µä¸‹ï¼Œè§‚å¯Ÿèµ„æºæ˜¯å¦å­˜åœ¨ã€‚
        }

        weak_ptr<T>& operator=(const shared_ptr<T>& other) {
            _ptr = other.get();  // è·å– shared_ptr çš„èµ„æºæŒ‡é’ˆå¹¶èµ‹ç»™ weak_ptr çš„ _ptr æˆå‘˜

            return *this;  // è¿”å›å½“å‰çš„ weak_ptr å¯¹è±¡ï¼Œä»¥æ”¯æŒé“¾å¼èµ‹å€¼æ“ä½œ
        }

        ~weak_ptr() {}
    };
```

```c++
template <class T>
struct ListNode {
    ListNode<T>* _prev = nullptr;
    ListNode<T>* _next = nullptr;

    ListNode() = default;
};

void test() {
    // ä½¿ç”¨ weak_ptr è§‚å¯Ÿ n1 å’Œ n2ï¼Œè€Œä¸å¢åŠ å¼•ç”¨è®¡æ•°
    weak_ptr<ListNode<int>> weak_n1(n1);  // weak_ptr è§‚å¯Ÿ n1
    weak_ptr<ListNode<int>> weak_n2(n2);  // weak_ptr è§‚å¯Ÿ n2

    // ç°åœ¨ï¼Œn1 å’Œ n2 å¯ä»¥æ­£ç¡®é”€æ¯ï¼Œå¼•ç”¨è®¡æ•°å˜ä¸º 0 æ—¶èµ„æºè¢«é‡Šæ”¾
}

```

# 3. æ€»ç»“

## **1. å¼‚å¸¸å¤„ç†**

* **C ä¼ ç»Ÿçš„é”™è¯¯å¤„ç†æ–¹å¼**ï¼š
  * **ç»ˆæ­¢ç¨‹åºï¼ˆ`assert`ï¼‰**ï¼šç®€å•ç›´æ¥ï¼Œä½†ç”¨æˆ·ä½“éªŒå·®ï¼Œç¨‹åºä¼šçªç„¶ç»ˆæ­¢ã€‚
  * **è¿”å›é”™è¯¯ç **ï¼šå¢åŠ äº†é”™è¯¯å¤„ç†çš„å¤æ‚åº¦ï¼Œç¨‹åºå‘˜éœ€è¦æ‰‹åŠ¨æ£€æŸ¥å’Œå¤„ç†æ¯ä¸ªé”™è¯¯ç ã€‚
* **C++ å¼‚å¸¸æœºåˆ¶**ï¼š
  * **å¼‚å¸¸æŠ›å‡º**ï¼šé€šè¿‡ `throw` æŠ›å‡ºå¼‚å¸¸ï¼Œ`throw` åè·Ÿéšé”™è¯¯ä¿¡æ¯ï¼Œä¼ é€’ç»™è°ƒç”¨è€…ã€‚
  * **å¼‚å¸¸æ•è·**ï¼šä½¿ç”¨ `try-catch` å—æ¥æ•è·å¹¶å¤„ç†å¼‚å¸¸ã€‚é€šè¿‡ `catch` å¯ä»¥æ•è·ç‰¹å®šç±»å‹çš„å¼‚å¸¸ï¼Œå¹¶æä¾›ç›¸åº”çš„å¤„ç†æœºåˆ¶ã€‚
  * **å¼‚å¸¸ä¼ æ’­**ï¼šå¼‚å¸¸ä¼šä»æŠ›å‡ºç‚¹æ²¿è°ƒç”¨æ ˆä¼ æ’­ï¼Œç›´åˆ°æ‰¾åˆ°åŒ¹é…çš„ `catch` å—ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…ï¼Œç¨‹åºç»ˆæ­¢ã€‚
  * **å¤šå±‚æ¬¡çš„å¼‚å¸¸åŒ¹é…**ï¼šå¼‚å¸¸å¯ä»¥åœ¨ä¸åŒå±‚æ¬¡çš„ `catch` å—ä¸­è¢«æ•è·ã€‚ä¾‹å¦‚ï¼Œå‡½æ•° `func1` æŠ›å‡ºçš„å¼‚å¸¸å¯ä»¥é€šè¿‡ `func2` å’Œ `main` é€å±‚æ•è·ã€‚
* **å¼‚å¸¸çš„æ‹·è´ä¸é‡æ–°æŠ›å‡º**ï¼š
  * å¼‚å¸¸å¯¹è±¡ä¼šåœ¨è¢«æŠ›å‡ºæ—¶è¢«æ‹·è´åˆ°è°ƒç”¨æ ˆä¸­ï¼Œå› æ­¤ `catch` å—å¯ä»¥è®¿é—®å®ƒã€‚
  * **é‡æ–°æŠ›å‡º**ï¼šæ•è·å¼‚å¸¸åï¼Œå¯ä»¥é€šè¿‡ `throw;` é‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Œäº¤ç»™æ›´å¤–å±‚çš„ `catch` å—ç»§ç»­å¤„ç†ã€‚
* **å¼‚å¸¸è§„èŒƒ**ï¼š
  * C++11 å¼•å…¥äº† `throw()` å’Œ `noexcept` è¯­æ³•ï¼Œåˆ†åˆ«è¡¨ç¤ºä¸€ä¸ªå‡½æ•°ä¸æŠ›å‡ºä»»ä½•å¼‚å¸¸å’Œä¿è¯ä¸æŠ›å‡ºå¼‚å¸¸ã€‚
  * å¼‚å¸¸çš„ä½¿ç”¨å¸¦æ¥äº† **æ€§èƒ½å¼€é”€** å’Œ **æ§åˆ¶æµå¤æ‚æ€§**ï¼Œä½†å®ƒä¹Ÿæä¾›äº† **é”™è¯¯åˆ†ç¦»**ã€**è‡ªåŠ¨æ¸…ç†** å’Œ **è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯**ã€‚

## **2. æ™ºèƒ½æŒ‡é’ˆ**

* **ä¸ºä»€ä¹ˆéœ€è¦æ™ºèƒ½æŒ‡é’ˆ**ï¼š
  * æ‰‹åŠ¨ç®¡ç†åŠ¨æ€å†…å­˜å®¹æ˜“å‡ºç° **å†…å­˜æ³„æ¼**ï¼Œä¾‹å¦‚å½“æŠ›å‡ºå¼‚å¸¸æ—¶æ²¡æœ‰é‡Šæ”¾å†…å­˜ã€‚
  * æ™ºèƒ½æŒ‡é’ˆè‡ªåŠ¨ç®¡ç†èµ„æºçš„ç”Ÿå‘½å‘¨æœŸï¼Œé€šè¿‡ **RAIIï¼ˆResource Acquisition Is Initializationï¼‰** æœºåˆ¶ï¼Œåœ¨å¯¹è±¡é”€æ¯æ—¶è‡ªåŠ¨é‡Šæ”¾èµ„æºã€‚
* **æ™ºèƒ½æŒ‡é’ˆçš„ç§ç±»**ï¼š
  * **`unique_ptr`**ï¼šç‹¬å æ‰€æœ‰æƒï¼Œä¸èƒ½æ‹·è´æˆ–èµ‹å€¼ï¼Œé¿å…äº†èµ„æºå…±äº«æ—¶çš„å†²çªã€‚
  * **`shared_ptr`**ï¼šå…±äº«æ‰€æœ‰æƒï¼Œé€šè¿‡ **å¼•ç”¨è®¡æ•°** æœºåˆ¶å®ç°å¤šä¸ªæ™ºèƒ½æŒ‡é’ˆå…±äº«åŒä¸€èµ„æºï¼Œç›´åˆ°æ‰€æœ‰ `shared_ptr` è¢«é”€æ¯æ—¶ï¼Œèµ„æºæ‰ä¼šé‡Šæ”¾ã€‚
  * **`weak_ptr`**ï¼šè§‚å¯Ÿ `shared_ptr` ç®¡ç†çš„èµ„æºï¼Œä¸å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œé˜²æ­¢å¾ªç¯å¼•ç”¨ã€‚
* **`shared_ptr` çš„å·¥ä½œåŸç†**ï¼š
  * **å¼•ç”¨è®¡æ•°**ï¼šæ¯ä¸ª `shared_ptr` æŒæœ‰ä¸€ä¸ªèµ„æºçš„å¼•ç”¨è®¡æ•°ï¼ŒæŒ‡ç¤ºæœ‰å¤šå°‘ä¸ª `shared_ptr` ç®¡ç†è¿™ä¸ªèµ„æºã€‚å½“å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶ï¼Œèµ„æºä¼šè¢«è‡ªåŠ¨é”€æ¯ã€‚
  * **æ‹·è´æ„é€ ä¸èµ‹å€¼**ï¼šæ‹·è´ `shared_ptr` æ—¶ï¼Œå¼•ç”¨è®¡æ•°å¢åŠ ï¼›èµ‹å€¼æ—¶ï¼Œä¼šå…ˆé‡Šæ”¾æ—§èµ„æºï¼Œå†å¤åˆ¶æ–°èµ„æºã€‚
* **å¾ªç¯å¼•ç”¨é—®é¢˜**ï¼š
  * **å¾ªç¯å¼•ç”¨**ï¼šå½“ä¸¤ä¸ª `shared_ptr` äº’ç›¸å¼•ç”¨æ—¶ï¼Œå®ƒä»¬çš„å¼•ç”¨è®¡æ•°æ°¸è¿œä¸ä¸º 0ï¼Œä»è€Œå¯¼è‡´å†…å­˜æ³„æ¼ã€‚
  * **è§£å†³æ–¹æ¡ˆ**ï¼šä½¿ç”¨ `weak_ptr` ä»£æ›¿ `shared_ptr`ï¼Œ`weak_ptr` ä¸å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œæ‰“ç ´å¾ªç¯å¼•ç”¨ï¼Œé¿å…å†…å­˜æ³„æ¼ã€‚

## **3. æ ˆå±•å¼€å’Œå¼‚å¸¸ä¼ æ’­**

* å¼‚å¸¸ä»æŠ›å‡ºç‚¹æ²¿ç€è°ƒç”¨æ ˆå‘ä¸Šä¼ æ’­ï¼Œç›´åˆ°æ‰¾åˆ°åŒ¹é…çš„ `catch` å—ã€‚å¦‚æœæ²¡æœ‰åŒ¹é…çš„ `catch`ï¼Œç¨‹åºç»ˆæ­¢ã€‚
* **æ ˆå±•å¼€**ï¼šå½“å¼‚å¸¸è¢«æŠ›å‡ºæ—¶ï¼Œç¨‹åºä¼šä»å½“å‰å‡½æ•°é€å±‚é€€å‡ºï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªåŒ¹é…çš„å¼‚å¸¸å¤„ç†å™¨ã€‚
* å¼‚å¸¸æ•è·åå¯ä»¥é€šè¿‡ `throw` é‡æ–°æŠ›å‡ºï¼Œäº¤ç»™ä¸Šå±‚ç»§ç»­å¤„ç†ã€‚

