## 一、整数存储：原码 / 反码 / 补码

### 1. 基本定义（以 char 为例，1 字节 = 8 位）

整数在内存中以**补码**存储，先明确原码、反码、补码的转换规则：

| 类型 | 正数（如 9）                   | 负数（如 - 9）                     |
| ---- | ------------------------------ | ---------------------------------- |
| 原码 | 符号位 (0)+ 数值位：`00001001` | 符号位 (1)+ 数值位：`10001001`     |
| 反码 | 与原码相同：`00001001`         | 符号位不变，数值位取反：`11110110` |
| 补码 | 与原码相同：`00001001`         | 反码 + 1：`11110111`               |

> 注：符号位是最高位，0 表示正，1 表示负；只有负数需要转换反码 / 补码，正数三者一致。

### 2. 为什么内存里存补码？（面试核心答案）

CPU 硬件设计和数值运算的双重需求，核心原因有 3 点：

#### （1）统一符号位与数值域，消除「-0」问题

* 原码 / 反码中，`10000000` 表示 - 0，`00000000` 表示 + 0，「-0」是无意义的冗余值；
* 补码中，`10000000` 被定义为 - 128（char 范围：-128~127），值域更合理（原码 / 反码仅 - 127~127），无冗余的 - 0。

#### （2）CPU 仅需加法器，减法转加法

硬件层面，CPU 只设计加法器即可完成加减运算（减法 = 加负数的补码），无需单独设计减法器，降低硬件复杂度：例：计算 `9 - 9 = 9 + (-9)`

* 原码相加：`00001001 + 10001001 = 10010010`（原码对应 - 18，错误）；
* 补码相加：`00001001 + 11110111 = 1 00000000`（截断进位后为 0，正确）。

#### （3）运算规则统一

正负数的加法、减法都能通过补码统一为加法规则，无需区分符号位特殊处理，提升运算效率。

## 二、大小端：概念 + 面试级判断代码

### 1. 核心概念

多字节数据（如 int、long）在内存中的存储顺序，内存地址「低→高」对应字节「高→低」或「低→高」：

| 端模式                | 定义（核心：高位 / 低位字节的存储位置）                | 示例（0x12345678，4 字节 int） |
| --------------------- | ------------------------------------------------------ | ------------------------------ |
| 大端（Big Endian）    | 高位字节存低地址，低位字节存高地址（符合人类读写习惯） | 低地址→高地址：`12 34 56 78`   |
| 小端（Little Endian） | 低位字节存低地址，高位字节存高地址（x86/x64 架构主流） | 低地址→高地址：`78 56 34 12`   |

> 面试考点：网络字节序是大端，跨平台传输需用`htons/htonl`转换；文件 / 硬件通信可能涉及大小端适配。

### 2. 两种判断机器字节序的代码（面试必写）

#### 方法 1：强转 char*（最常用，效率高）

利用 char 仅占 1 字节，读取多字节数据的最低地址字节：

cpp



运行









```cpp
#include <iostream>
using namespace std;

// 返回1：小端；返回0：大端
int checkEndian() {
    int num = 1; // 二进制：00000000 00000000 00000000 00000001
    char* p = (char*)&num; // 指向num的最低地址
    return *p == 1; // 小端：最低地址存低位字节（1）；大端：存高位字节（0）
}

int main() {
    cout << (checkEndian() ? "小端序" : "大端序") << endl;
    return 0;
}
```

#### 方法 2：union 联合体（利用成员共享内存）

联合体的所有成员共享同一块内存空间，通过 char 成员读取 int 的最低地址字节：

cpp



运行









```cpp
#include <iostream>
using namespace std;

union EndianCheck {
    int i;   // 4字节
    char c;  // 1字节（共享i的最低地址）
};

int checkEndian() {
    EndianCheck ec;
    ec.i = 1;
    return ec.c == 1; // 小端返回1，大端返回0
}

int main() {
    cout << (checkEndian() ? "小端序" : "大端序") << endl;
    return 0;
}
```

## 三、有符号 / 无符号坑（面试高频错题）

### 1. 核心问题

C++ 标准规定：**有符号数与无符号数混合运算时，有符号数会隐式转换为无符号数**；无符号数永远≥0，易导致循环、比较、数组索引出错。

### 2. 典型例题 + 面试分析

#### 例题 1：循环下溢（死循环）

cpp



运行









```cpp
// 错误代码
for (unsigned int i = 9; i >= 0; i--) {
    cout << i << endl; // 死循环！
}
```

**分析**：

* i 是 unsigned，永远满足`i >= 0`；
* i 减到 0 后，再减 1 会触发「无符号溢出回绕」，变成`UINT_MAX`（4294967295），循环永不终止。

**面试追问：如何修复？**

cpp



运行









```cpp
// 修复方案1：改用有符号数int
for (int i = 9; i >= 0; i--) {
    cout << i << endl;
}

// 修复方案2：调整循环条件（保留unsigned）
for (unsigned int i = 9; i > 0; i--) {
    cout << i << endl; // 输出9~1
}
// 或输出9~0：
for (unsigned int i = 10; i > 0; ) {
    cout << --i << endl;
}
```

#### 例题 2：有符号与无符号比较

cpp



运行









```cpp
int a = -1;
unsigned int b = 1;
if (a > b) {
    cout << "a > b" << endl; // 实际输出这个！
} else {
    cout << "a <= b" << endl;
}
```

**分析**：

* a（int=-1）与 b（unsigned）比较时，a 被转换为 unsigned int；
* -1 的补码是`0xFFFFFFFF`（32 位），转换为 unsigned 后是`4294967295`，远大于 1，因此`a > b`成立。

#### 例题 3：数组越界（无符号索引）

cpp



运行









```cpp
int arr[5] = {1,2,3,4,5};
for (unsigned int i = 0; i < 5; i++) {
    cout << arr[i - 1] << endl; // i=0时越界！
}
```

**分析**：i=0 时，`i-1`是无符号溢出，结果为`UINT_MAX`，访问`arr[UINT_MAX]`触发未定义行为（崩溃 / 乱码）。

### 3. 面试避坑建议

1. 循环索引优先用`int`（除非明确需要无符号，如数组大小`size_t`）；
2. 避免有符号 / 无符号混合比较 / 运算，必要时显式转换（如`(int)b`）；
3. 无符号数的循环条件避免`>=0`，改用`>0`或其他边界。

## 四、浮点数 IEEE754（面试核心：结构 + 例题解析）

C++ 中`float`（单精度 32 位）、`double`（双精度 64 位）遵循 IEEE754 标准，与整数的补码存储完全不同。

### 1. 单精度 float（32 位）结构

| 位段 | 符号位 S    | 指数位 E                   | 尾数位 M                                           |
| ---- | ----------- | -------------------------- | -------------------------------------------------- |
| 位数 | 1           | 8                          | 23                                                 |
| 作用 | 0 正 / 1 负 | 存储偏移指数（偏移量 127） | 存储有效数字的小数部分（整数部分固定为 1，隐藏位） |

**数值公式**：`V = (-1)^S × (1.M) × 2^(E - 127)`

* `1.M`：有效数字（如 M=0001001，则 1.M=1.0001001）；
* `E-127`：真实指数（E 是存储的偏移指数，需减 127）。

> 双精度 double：S=1 位，E=11 位（偏移量 1023），M=52 位，公式：`V = (-1)^S × (1.M) × 2^(E - 1023)`。

### 2. 典型例题解析（面试必考）

cpp



运行









```cpp
int n = 9;
float* p = (float*)&n;
cout << *p << endl; // 输出~1.26117e-44（离谱的小数）
```

**底层分析（核心：内存二进制重新解析）**：

1. `n=9`的 int 二进制（32 位补码）：`00000000 00000000 00000000 00001001`；

2. `(float*)&n`仅改变指针类型，内存二进制不变，`*p`按 IEEE754 解析这段二进制：

   * S=0（最高位）；
   * E=00000000（接下来 8 位）；
   * M=0000000 00000000 00001001（最后 23 位）；

3. 特殊规则：E=0 时为「非规格化数」，公式变为：

   

   ```
   V = (-1)^S × (0.M) × 2^(1 - 127)
   ```

   ；

4. 计算：

   * `0.M = 9 / 2^23`（M 的二进制是 9）；
   * `2^(1-127) = 2^-126`；
   * 最终：`V = 9 × 2^-149 ≈ 1.26117×10^-44`。

**面试关键结论**：

* `(float*)&n`是「内存二进制重新解释」，而非数值转换；
* 数值转换应写`(float)n`（编译器会将 9 转为 IEEE754 的 float 编码：`01000001000100000000000000000000`，对应 9.0）。

### 3. 面试延伸考点

1. 为什么 0.1 无法精确存储？

   

   0.1 的二进制是

   ```
   0.0001100110011...
   ```

   （无限循环），float/double 只能截断，导致精度损失；

2. float 能精确表示的最大整数？

   

   2^24（23 位尾数位 + 1 位隐藏位，共 24 位有效数字），超过则无法精确存储；

3. NaN / 无穷大的存储？

   

   E 全 1（float=255）时，M=0 是 ± 无穷，M≠0 是 NaN（非数值）。

## 五、大厂面试补充考点（必掌握）

### 1. 内存布局（栈 / 堆 / 静态区 / 常量区 / 代码区）

| 区域        | 分配 / 释放     | 存储内容                     | 面试坑点                                        |
| ----------- | --------------- | ---------------------------- | ----------------------------------------------- |
| 栈（stack） | 自动分配 / 释放 | 局部变量、函数参数、返回地址 | 栈溢出（递归过深、局部数组过大）                |
| 堆（heap）  | 手动 new/malloc | 动态分配的对象 / 数组        | 内存泄漏、双重释放、野指针、碎片                |
| 静态区      | 程序启动 / 退出 | 全局变量、static 变量        | 局部 static 初始化时机（第一次执行）            |
| 常量区      | 只读，程序退出  | const 常量、字符串常量       | 修改字符串常量（`char* p="abc"; p[0]='x'`崩溃） |
| 代码区      | 只读，程序运行  | 编译后的机器码               | 代码段不可写                                    |

### 2. 内存对齐（结构体对齐）

#### 原因：

* 硬件要求：CPU 按字长（32 位 4 字节，64 位 8 字节）访问内存，非对齐访问触发总线错误或性能下降；
* 性能优化：对齐后 CPU 一次读取数据，无需分两次。

#### 默认对齐规则（32 位）：

1. 成员偏移量是自身大小的整数倍；
2. 结构体总大小是最大成员大小的整数倍。

#### 面试例题：

cpp



运行









```cpp
struct A {
    char a;  // 偏移0，大小1 → 填充3字节（对齐4）
    int b;   // 偏移4，大小4
    short c; // 偏移8，大小2 → 填充2字节（总大小对齐4）
};
// 总大小：12（1+3+4+2+2）

// #pragma pack(2) 修改对齐系数后：
struct B {
    char a;  // 偏移0，大小1 → 填充1字节（对齐2）
    int b;   // 偏移2，大小4
    short c; // 偏移6，大小2
};
// 总大小：8（1+1+4+2）
```

### 3. 指针核心坑点

* 野指针：未初始化（`int* p; *p=10` → 未定义行为）；
* 悬垂指针：指向已释放的内存（`int* p=new int; delete p; *p=10`）；
* 空指针：C++11 后用`nullptr`（类型安全），避免`NULL`（0 的宏）；
* 避免方案：初始化指针、释放后置`nullptr`、优先用智能指针（`unique_ptr/shared_ptr`）。

### 4. 类型转换底层

| 转换方式         | 底层逻辑        | 面试考点                            |
| ---------------- | --------------- | ----------------------------------- |
| static_cast      | 编译期数值转换  | 基础类型 / 父子类向上转换           |
| reinterpret_cast | 二进制重新解释  | int*→float*（如前面的例题），风险高 |
| const_cast       | 移除 const 属性 | 修改常量区的 const 变量会崩溃       |
| dynamic_cast     | 运行时类型检查  | 父子类向下转换，需虚函数            |

## 总结

大厂面试对 C++ 底层的考察核心是「原理 + 落地」：

1. 整数补码：理解 CPU 加法器设计和值域统一；
2. 大小端：能手写判断代码，知道网络字节序；
3. 无符号坑：能分析循环 / 比较错误，给出避坑方案；
4. IEEE754：能解析 int→float 的离谱输出，理解存储结构；
5. 补充考点：内存布局、对齐、指针是延伸高频题，需结合代码