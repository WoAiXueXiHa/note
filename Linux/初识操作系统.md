# 1. 冯诺依曼体系结构

我们常见的计算机，都遵循冯诺依曼体系结构

![image-20251217203308021](https://gitee.com/binary-whispers/pic/raw/master///20251217203310760.png)

* **输入设备：** 键盘、鼠标、网卡、磁盘、话筒...
* **输出设备：** 显示器、磁盘、网卡、打印机...
* **存储器：** 内存，和磁盘这样的内存相对应

所有的数据流转都遵循以下原则：

**CPU在数据层面，不和外设直接交互，只能和存储器（即内存）交互！！！**

举个例子：一个二进制文件运行在显示器上显示的过程：

二进制可执行文件-->磁盘-->存储器-->CPU-->存储器-->显示器

**任何程序要运行，必须从磁盘加载到内存之后，经过CPU处理才能运行！！！**——这是冯诺依曼体系结构决定的！！！

为什么要设计存储器？

**外设IO处理效率极低，CPU处理效率极高，二者运行效率不是一个量级的，内存作为链接二者的巨大缓存**

如果跳过内存：

![image-20251217172703694](https://gitee.com/binary-whispers/pic/raw/master///20251217172706373.png)

根据木桶效应，整个系统效率取决于效率低的模块，而这样设计，不合理

再来看一下存储金字塔：

![image-20251217192020590](https://gitee.com/binary-whispers/pic/raw/master///20251217192023825.png)

所以，冯诺依曼体系结构是个伟大的发明，让普通人也能用上计算机。

我们再举个例子理解一下冯诺依曼体系结构的数据流向：

> 从登录上qq开始和某位朋友聊天开始，数据的流动过程：假设发送“hehe”，此时不考虑网络层
>
> 1. 键盘键入消息“hehe”，经过输入设备输入到存储器
> 2. 存储器将消息“hehe”传输到CPU
> 3. CPU经过处理，解密翻译，重新输出到存储器内
> 4. 存储器将处理过的数据输出到网卡
>
> 此时，发送消息完成，经过网络层到达某位朋友的网卡
>
> 1. 网卡接收到“hehe”数据，输入到存储器中
> 2. 存储器将消息“hehe”传输到CPU
> 3. CPU经过处理，解密翻译，重新输出到存储器内
> 4. 存储器将处理过的数据输出到显示器上

****



# 2. 操作系统相关概念

广义上来讲，OS包括外壳程序和内核两部分

狭义上来讲，OS一般只谈内核

![image-20251217201053266](https://gitee.com/binary-whispers/pic/raw/master///20251217201057392.png)

这样设计的目的是：

> * 对上层，给用户程序提供稳定、高效、安全的运行环境
> * 对下层，能稳定、高效、安全地管理硬件设备

![image-20251217202624250](https://gitee.com/binary-whispers/pic/raw/master///20251217202627320.png)

所以，操作系统的核心是**管理**，管理好上层和下层，围绕**先描述，再组织**的核心思想：

> * 对上层：
>   * 用户/应用不会直接操作OS的内部模块，二通过OS提供的简化接口来提需求：比如开发者在代码里调用lib的“文件读取函数”，这些操作会通过“系统调用接口”传给OS
>   * 简单来说：OS把**进程、内存分配**等复杂逻辑藏起来，**给上层用户/应用提供简单易懂的操作入口**
> * 对下层：
>   * 不同硬件的工作逻辑差异很大，OS不直接操作硬件，而是通过调用对应的驱动程序来控制硬件：比如要保存文档到硬盘，OS的文件管理模块不会直接和硬盘交互，而是调用“硬盘驱动”，让驱动按照硬盘的设计完成数据写入
>   * 简单来说：OS把“不同硬件的复杂操作”抽象成统一的管理逻辑，**向下统一管理各种硬件**

根据上述：OS是**中间连接层**

*  **向上：通过 “接口封装”，把复杂的系统功能简化成用户 / 应用能轻松用的操作**
*  **向下：通过 “硬件抽象”，把多样的硬件操作统一成系统能管控的资源**

最终实现的效果是：用户不用懂 OS 内部逻辑，硬件不用管上层需求，OS 靠 “上下管理” 让整个系统有序运行

