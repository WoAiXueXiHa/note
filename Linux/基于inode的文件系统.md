# 持久化存储的发展

早在几千年前，祖先在石头上刻字刻画，就是最早的持久化存储形式

![image-20260107220414916](https://gitee.com/binary-whispers/pic/raw/master///20260107220418301.png)

但是这种方式只做到了持久化存储，如果还要**能反复改写的持久化存储**呢？

![image-20260107220547524](https://gitee.com/binary-whispers/pic/raw/master///20260107220549683.png)

这种儿童益智玩具就可以**寻址+反复改写**

现在思考，我们如何持久化存储1bit接着1bit的数据？

可以把bits卷起来->磁带诞生 1D线性

![](https://gitee.com/binary-whispers/pic/raw/master///20260107220904123.png)

![image-20260107221512010](https://gitee.com/binary-whispers/pic/raw/master///20260107221514029.png)

把磁带抽象一下就是这种结构，磁极N/S就可以代表0/1，纸带上均匀沾上铁磁性颗粒，用一个机械部件转动定位，写入0/1数据

* 读取：放大感应电流
* 写入：读写头改变磁畴磁化方向

但是这种方式**顺序读写需要等待定位，随机读写几乎实现不了**，如今基本被淘汰

那么再优化呢，利用旋转的二位平面存储（不能内卷纸带了）->于是磁鼓被发明了，1.5D旋转

![image-20260107222132186](https://gitee.com/binary-whispers/pic/raw/master///20260107222134056.png)

这种方式鼓面面积有限，容量太小了！但是首次实现了**局部化寻址**

考虑一下，让读写头进行移动呢？->磁盘出现，2.5D多盘

![image-20260107222522910](https://gitee.com/binary-whispers/pic/raw/master///20260107222525639.png)

磁盘是现在服务器常用的存储设备，可靠性搞，容量大

而还有个有趣的现象，我们电脑的盘符是从C盘开始往后分布的，AB盘呢？

为了解决“数据需要移动”的问题，软盘诞生，2.5D可移动

早期没有硬盘时，PC 靠双软驱解决数据存储 / 拷贝，系统给两个软驱分配 A、B 盘符，对应插入的软盘就是 A 盘、B 盘

不过现在软盘也基本被淘汰

****

# 2. 磁盘详解

## 基本描述

机械磁盘属于外设

核心特点：**容量大、价格便宜、读写速度慢（受机械部件运动限制）**

存储本质：利用磁头改变磁盘表面磁畴的磁化方向，实现二进制数据的持久化

![image-20260107223519001](https://gitee.com/binary-whispers/pic/raw/master///20260107223520926.png)

这是磁盘的物理结构

![image-20260107224124984](https://gitee.com/binary-whispers/pic/raw/master///20260107224128077.png)

这是磁盘的存储结构

###  物理组件与功能（文档图示解析）

|       组件       |                           功能描述                           |                         关键特性                         |
| :--------------: | :----------------------------------------------------------: | :------------------------------------------------------: |
| 盘片（Platter）  |                      数据存储的物理介质                      | 可多个叠放（如 2 个盘片 = 4 个盘面），由主轴带动高速旋转 |
|   磁头（Head）   |        固读写数据，与盘面保持微米级间隙（无物理接触）        |         每个盘面对应 1 个磁头，所有磁头 “共进退”         |
| 磁头臂（传动臂） |     连接所有磁头，沿半径方向移动，带动磁头定位到目标磁道     |      运动速度决定寻道时间，是磁盘延迟的主要来源之一      |
| 主轴（Spindle）  | 带动盘片高速旋转（常见 7200 转 / 分、10000 转 / 分），为数据读写提供相对运动 |                 旋转速度决定扇区定位延迟                 |
|      永磁铁      |         提供稳定磁场，辅助磁头实现磁畴磁化方向的改变         |      保障数据写入的稳定性，避免磁场干扰导致数据丢失      |

## 从磁道到扇区的层级划分

磁盘的存储单位是层级化的，从宏观到微观：**柱面->磁道->扇区**

> * 磁道（track）：盘片表面的**同心圆轨迹**，从外圈到内圈从0依次编号。外圈磁道周长更长，但扇区数量与内圈磁道相同->外圈磁道面密度更高
> * 柱面（cylinder）：所有盘片上半径相同的磁道组成的**圆柱形区域**。所有磁头共进退，同步移动到统一柱面，同时访问多个磁道。柱面是**分区的最小单位**
> * 扇区：磁道被划分为**扇形区域**，**磁盘物理存储的最小单位->默认512字节**，扇区编号从1开始

$磁盘容量 = 磁头数 \times 柱面数 \times 每磁道扇区数 \times 每扇区字节数(512B) $

例如：2个磁盘，1024个柱面，每磁道63扇区->`2*2*1024*63*512B = 128MB`

## 磁盘寻址方式

将磁道展开：

![image-20260108193042830](https://gitee.com/binary-whispers/pic/raw/master///20260108193045840.png)

将柱面展开：

![image-20260108193106371](https://gitee.com/binary-whispers/pic/raw/master///20260108193107966.png)

将整盘展开：

![image-20260108193132221](https://gitee.com/binary-whispers/pic/raw/master///20260108193134138.png)

根据结构，寻址一个扇区：先定位柱面（cylinder）->后定位磁道，其实就是磁头的位置（head）->最后定位扇区（sector）

这便是`CHS`寻址法

![image-20260108193647722](https://gitee.com/binary-whispers/pic/raw/master///20260108193650938.png)

其实都可以看作一维数组，每个扇区有一个索引，叫做`LBA(logical block address)`

* CHS->LBA

  $LBA = 柱面号C \times 单个柱面扇区总数 \times 磁头号H \times 每磁道扇区数 + 扇区号S - 1$

  * 扇区号从1开始，LBA中的索引从0开始，所以要减去1

  * 柱面和磁道都是从零开始编号

* LBA->CHS
  * 柱面号C = LBA // 单个柱面扇区总数
  * 剩余扇区数 = LBA % 单个柱面扇区总数
  * 磁头号H = 剩余扇区数 // 每磁道扇区数
  * 扇区号S = (剩余扇区数 % 每磁道扇区数) + 1
  * //代表除取整

例如：4 个磁头、63 扇区、LBA=1000

* 柱面号C = 1000 // 4*63 = 3
* 磁头号H = （1000 % 252）// 63 = 3
* 扇区号S = （1000 % 252）% 63 +1 = 6

# 3. 文件系统

## 块概念

硬盘是块设备，OS读取硬盘数据，一次性连续读取多个扇区->一次性读取一个块（block）

硬盘的每个分区被划分成一个一个的块，一个块的大小由格式化的时候确定，不可更改

最常见的是4KB，**8个连续扇区组成一个块**，**块是文件存取的最小单位**

每个扇区都有LBA，8个扇区一个块，每一个块的地址也可计算

* 知道LBA：块号 = LBA / 8
* 知道块号： LBA = 块号*8+n（n为块内第几个扇区）

![image-20260108201415562](https://gitee.com/binary-whispers/pic/raw/master///20260108201417377.png)

```bash
[vect@VM-0-11-centos ~]$ sudo fdisk -l /dev/vda
[sudo] password for vect: 

Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0009ac89

   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *        2048   104857566    52427759+  83  Linux

```

这是云服务器磁盘的信息

## 分区概念

磁盘可以被划分成多个分区，就比如Windows，将一块磁盘分成C,D,E盘，C,D,E就是分区

分区本质是**对硬盘的一种格式化**

在Linux系统，**柱面是分区的最小单位**

![image-20260108201632128](https://gitee.com/binary-whispers/pic/raw/master///20260108201634224.png)

## `inode`概念

文件=数据+属性

![image-20260108202047148](https://gitee.com/binary-whispers/pic/raw/master///20260108202049365.png)

还可以用`stat`指令查询文件信息：

```bash
[vect@VM-0-11-centos disk]$ stat file.txt 
  File: ‘file.txt’
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: fd01h/64769d	Inode: 1052555     Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1002/    vect)   Gid: ( 1002/    vect)
Access: 2026-01-08 20:18:50.679009989 +0800
Modify: 2026-01-08 20:18:50.679009989 +0800
Change: 2026-01-08 20:18:50.679009989 +0800
 Birth: -

```

每个文件对应一个`inode`

`inode`后面包含七列：

> * 权限
> * 硬链接数
> * 拥有者
> * 所属组
> * 大小
> * 最后修改时间
> * 文件名

每个文件对应一个`inode`

需要注意：

> * **文件的属性和内容是分开存储的**
> * 保存文件属性的集合叫`inode`，一个文件对应一个`inode`，`inode`里有一个唯一的标识符->`inode`号
> * **文件名不在`inode`数据结构内部**
> * `inode`的大小一般是128或256字节，任何文件的属性大小都相同



# 3.基于`inode`的ext2文件系统

## 文件系统结构组成

### 宏观结构

**要在硬盘上存文件，必须先把硬盘格式化成为某种格式的文件系统，目的是组织和管理硬盘文件**

Linux和Mac系统基于`inode`构成文件系统

Windows系统基于`FAT`构成文件系统

ext2文件系统将一个分区划分成若干个同样大小的块组（block group），管理好一个分区就能将这个方法（文件系统）用于其他分区，从而管理好磁盘里的所有文件

![image-20260108205539007](https://gitee.com/binary-whispers/pic/raw/master///20260108205541454.png)

boot sector的大小是确定的1KB，由PC标准规定，存储磁盘分区信息和启动信息，写死了，不能修改

### Super Block

存放文件系统本身的结构信息，描述整个分区的文件系统信息，是文件系统的大脑

主要的信息有：block和inode的总量，未使用的block和inode的数量，一个block和inode的大小，最近一次写入时间等。

Super Block的信息被破坏可以说整个文件系统结构就被破坏了，所以超级块**在多个块组中备份**

查看超级块信息：`sudo dumpe2fs -h /dev/vda1`

### GDT（global descripptor table）

每个块组对应一个描述符，告诉内核该块组的位图、inode表在哪，剩余多少资源，比卖你遍历整个分区查找组件

以下是关键结构体字段：

```cpp
struct ext2_group_desc {
    __le32 bg_block_bitmap;   // 块位图的块地址（该块组的块位图存在哪个块）
    __le32 bg_inode_bitmap;   // inode位图的块地址
    __le32 bg_inode_table;    // inode表的起始块地址
    __le16 bg_free_blocks_count; // 该块组空闲块数
    __le16 bg_free_inodes_count; // 该块组空闲inode数
};
```

GDT也会在多个块组中备份，和超级块同步，保证块组信息不丢失

### 位图 block bitmap/ inode bitmap

用1bit位映射1个资源的状态，解决遍历所有块/inode找空闲资源的低效策略

这里再讲一下位图的原理：

> * 本质：**1bit=1资源**，空间换时间，4KB块可以管理$8\times1024\times4=32768$个资源
> * 核心规则：
>   * bit==0：资源空闲
>   * bit==1：资源占用

block bitmap标记数据块的占用状态，inode bitmap标记inode的占用状态

### inode table

inode表存储块组内所有文件的inode（索引节点），每个inode存储一个文件的属性，和文件内容分离

> * inode表由**连续块组成**，4KB块可以存储32个128字节的inode或16个256字节的inode
>
> * inode编号：分区内唯一，从1开始（0预留）
>
>   $inode号 = 块组编号\times每块组inode数+块组内偏移量$
>
>   `ls -i`查看文件名和inode号

### data blocks

数据块存储文件内容，按照文件类型不同存储不同内容：

* 普通文件：二进制数据
* 目录：**文件名->inode号**映射表，**inode里不存文件名！inode给OS看！文件名给用户看！**
* 软连接：相当于与快捷方式，有自己的inode，是独立文件



## inode更深层次理解

### inode和数据块的映射

inode是ext文件系统的核心，文件=inode（属性）+数据块（内容），二者通过`i_block[15]`指针关联

**inode核心结构体：**

```cpp
struct ext2_inode {
    __le16 i_mode;          // 文件类型+权限（如0644=普通文件，0755=目录，面试必记）
    __le32 i_size;          // 文件大小（字节）
    __le32 i_atime;         // 访问时间（读内容触发，如cat）
    __le32 i_mtime;         // 修改时间（改内容触发，如echo）
    __le32 i_ctime;         // 变更时间（改属性触发，如chmod）
    __le16 i_links_count;   // 硬链接数（删除文件的关键判断）
    __le32 i_block[15];     // 15个数据块指针（核心！12直接+1一级+1二级+1三级）
};
```

![image-20260108215416097](https://gitee.com/binary-whispers/pic/raw/master///20260108215418427.png)

|   指针类型   | 数量  |                         寻址逻辑                          | 支持容量 |     计算逻辑      |
| :----------: | :---: | :-------------------------------------------------------: | :------: | :---------------: |
|  直接块指针  | 12 个 |                      直接指向数据块                       |   48KB   |     12 × 4KB      |
| 一级索引指针 | 1 个  | 指向 “一级索引”（该块存储 1024 个数据块号，4KB÷4B=1024）  |   4MB    |    1024 × 4KB     |
| 二级索引指针 | 1 个  | 指向 “一级索引→二级索引”（二级索引存储 1024 个数据块号）  |   4GB    | 1024 × 1024 × 4KB |
| 三级索引指针 | 1 个  | 指向 “一级→二级→三级索引”（三级索引存储 1024 个数据块号） |   4TB    |    1024³ × 4KB    |

思考：

* 62KB文件的映射逻辑？

  62KB=12*4KB（12个直接指针）+14KB（还要4个数据块）->一级索引指针->索引表中前4个数据块号

* ext2文件系统中，4KB块大小，一个文件最大支持多大？

  48KB+4MB+4GB+4TB->4TB

注意：

> * **文件名存在目录中，inode只存储属性和数据块指针！**
> * **inode大小固定！128/256字节，文件大小变化是数据块大小在变化！**

## 文件的生命周期：创建/读取/删除的底层逻辑

结合块组组件和inode映射，以`touch abc`、`cat abc`、 `rm abc`为例，梳理详细过程

### 创建文件

* **分配inode：**遍历inode位图，找到第一个bit==0的位置如（inode=105525），设为1，初始化元数据->文件权限，硬链接数
* **分配数据块：**空文件不分配；若有内容，遍历块位图找空闲块，写入`i_block`指针
* **更新目录：**在当前目录的数据块中，添加`abc:105525`映射（目录的本质是特殊文件）
* **同步元数据：**超级块、GDT的空闲inode/block数减一，更新最后写入时间

### 读取文件

![image-20260108220905591](https://gitee.com/binary-whispers/pic/raw/master///20260108220907503.png)

* **路径解析：**从根目录（inode=1，系统开机加载）开始，逐层找`home->vect->LinuxRepo->disk->abc`的inode号102252
* **缓存优化：**系统会将打开的文件目录缓存到dentry中，若路径在缓存中，直接取inode，不用读磁盘
* **读数据块：** 通过`i_block`找到数据块，先读内存，未找到再读磁盘
* **更新时间：** 修改inode的访问时间，同步到磁盘

### 删除文件

* **删除目录映射：** 在当前目录数据块中删除`abc:102252`
* **减少硬链接数：** inode中的`i_links_count--`，若>0，数据和inode不释放
* **释放资源：** 若`i_links_count==0`，块位图设0释放数据块，inode位图设0释放inode
* **同步元数据：** 超级块、GDT的空闲inode/block数加1

### 重新理解目录和文件名

提问：为什么访问文件都用的文件名，没用过inode啊？目录怎么理解？

> * 目录是文件，磁盘中没有目录的概念，只有文件属性+文件内容的概念
> * 目录保存的是文件名和inode号的映射关系，inode给OS看，文件名给人看

所以，访问文件，必须先打开文件所在目录（**本质是打开当前工作目录文件，查看目录文件内容**），根据文件名，获得对应inode号，然后才能访问

现在，重新再一次理解目录和文件权限！

> * 所有文件操作的前提是**找到文件inode**，找到inode必须通过目录，因此**目录权限是路径解析的通行证**
> * 文件的修改：目录`x`权限->找inode+文件`w`权限->改内容
> * 文件的删除：目录`x`权限->找inode+目录`w`权限->改映射，和文件自身权限无关
> * 目录`x`权限是**访问文件的核心前提**，没有`x`，任何文件操作都无法进行

## 路径解析和挂载

### 路径解析

* 核心逻辑： 从根目录（inode=1）递归解析，每层通过目录的数据块找“子目录/文件名->inode号”映射，直到找到目标文件
* 缓存优化：每次从根目录找太繁琐，定义`dentry`结构体在内存中维护路径树，记录“路径->inode”映射，减少对磁盘的访问

### 挂载

* 问题：inode号在分区内唯一，跨分区无法识别
* 解决方案：将分区和目录绑定，访问挂载点就能访问分区

# 4. 软硬链接

## 硬链接->不是独立文件、没有独立inode

* 多个文件名对应同一个inode**的映射关系，本质是**给一个文件起多个名字**

* 所有硬链接共享文件的属性和数据块，修改任意一个硬链接，其他都会同步变化

* `i_links_count`字段记录硬链接的数量，初始为1，只要**`i_links_count`>0，inode和数据块就不会释放，文件就还存在**

代码示例：

创建硬链接：`ln 源文件 新文件`

```bash
[vect@VM-0-11-centos disk]$ touch file
[vect@VM-0-11-centos disk]$ ls -il file 
1053094 -rw-rw-r-- 1 vect vect 0 Jan  8 22:52 file
[vect@VM-0-11-centos disk]$ ln file file_
[vect@VM-0-11-centos disk]$ ls -il file file_
1053094 -rw-rw-r-- 2 vect vect 0 Jan  8 22:52 file
1053094 -rw-rw-r-- 2 vect vect 0 Jan  8 22:52 file_

```

第一列的inode相同，2代表硬链接数

现在给`file_`写入内容查看两个文件，然后删除`file`再查看

```bash
[vect@VM-0-11-centos disk]$ cat file file_
[vect@VM-0-11-centos disk]$ vim file_
[vect@VM-0-11-centos disk]$ cat file_
hard file
[vect@VM-0-11-centos disk]$ cat file
hard file
[vect@VM-0-11-centos disk]$ rm file
[vect@VM-0-11-centos disk]$ cat file_
hard file
[vect@VM-0-11-centos disk]$ ls -il file_
1053094 -rw-rw-r-- 1 vect vect 10 Jan  8 22:57 file_

```

应用场景：

* 文件备份：创建硬链接，源文件误删后，只要有一个硬链接存在，文件就不会丢失
* 系统特殊目录：`.`和`..`本质是硬链接，创建一个空目录，它的硬链接数默认为2，一个是自己，一个是`.`

注意事项：不允许给目录创建硬链接，会成环！（特殊目录是写死的，特殊情况）

# 软连接->独立文件、有独立inode

* 软连接是**独立的文件**，有自己的inode、属性和数据块，但是数据块中不存储文件内容，**仅存储目标文件的路径**
* 访问软连接，内核会根据路径解析到目标文件，本质是快捷方式->路径转移

代码示例：

创建软连接：`ln -s 源文件 软链接文件`

```bash
[vect@VM-0-11-centos disk]$ >file
[vect@VM-0-11-centos disk]$ ln -s file file_soft
[vect@VM-0-11-centos disk]$ ls -il 
total 0
1051733 -rw-rw-r-- 1 vect vect 0 Jan  8 23:09 file
1052555 lrwxrwxrwx 1 vect vect 4 Jan  8 23:09 file_soft -> file

```

* 软连接固定权限是`777`

* 箭头->后指向目标文件，数据块进存储目标文件路径

  ![image-20260108231153226](https://gitee.com/binary-whispers/pic/raw/master///20260108231155304.png)

  文件不存在就会断裂链接

* 1是软连接自身的硬链接数



