# 1. 基本概念和基本操作

内核观点：进程是**担当分配系统资源（CPU时间、内存）的实体**

本质：**进程=内核数据结构+程序的代码和数据+进程地址空间(mm_struct)**

程序是静态的文件，进程是动态的执行过程，内核数据结构是进程的“身份证+状态记录”

**如何进行进程管理呢？--->先描述再组织**

![image-20251218124346545](https://i-blog.csdnimg.cn/img_convert/c30d92feaf0d8da4d8fe91bb6dbdaeb8.png)

* **先描述：**
  * **code.c：** 是**静态的源代码文件**，只包含程序的代码逻辑
  * **myexe：** 编译后的**二进制可执行文件**，静态的，存在磁盘中，包含程序初始数据和二进制代码
  * **磁盘：** **持久化存储介质**，存放未运行的静态程序文件
  * **内存：** **临时运行介质**，执行`./myexe`时，`myexe`的代码和数据会从磁盘加载到内存中，同时内核会为它创建PCB（process control block）
  * **PCB(Linux下是struct task_struct):** 进程的属性，每个PCB对应一个进程
  * **CPU：** **执行硬件** ，通过调度机制，从内存中的PCB链表中调度进程，执行对应的代码和数据
* **再组织：**
  1. 静态的`code.c`被编译成`myexe`，以文件形式加载到磁盘中
  2. 执行`myexe`时，OS先创建`task_struct`，将`myexe`的代码数据从磁盘加载到内存，最后将`task_struct`加入内核的进程链表
  4. CPU通过调度，从PCB链表中选择合适的进程，执行代码和数据

所以，**进程会被OS根据`task_struct`属性进行调度和执行**

****



# 2. PCB内部详细结构（task_struct详解）

PCB（Process Control Block，进程控制块）是内核用于描述进程的核心数据结构，Linux 下具体实现为`task_struct`，加载在内存中，包含进程所有属性

## 核心属性分类

> * 标识符(pid ppid)：描述本进程的唯一id，用于区别其他进程
> * 状态：任务状态、退出代码、退出信号等
> * 优先级：相对于其他进程，执行的先后顺序
> * 程序计数器：程序中即将被执行的下一条指令的地址
> * 内存指针：包括程序代码和进程相关数据的指针、其他进程共享的内存块的指针
> * 上下文数据：进程执行时寄存器中恢复的数据
> * IO状态信息
> * 记账信息：进程累计占用CPU时长，内存使用量、IO读写次数...

这些核心属性都会在下文一一讲解

## PCB的组织方式

Linux内核中，task_struct的核心组织方式是双链表（用于遍历所有进程），同时会用红黑树/哈希表优化PID查找、进程组管理等操作（双链表是基础）

![image-20251218144810233](https://i-blog.csdnimg.cn/img_convert/ac9e372c8aa17cb76b8f67e20c067e70.png)

内核通过遍历该链表管理所有进程，如查找、调度、终止进程

****



# 3. 如何查看进程？

##  `/proc`文件系统（内核直接暴露的进程信息）

我们一般是用户级别访问，而有些文件可能会访问受限

* 原理：Linux把每个进程的详细信息以目录形式存储在`/proc/[PID]`下

  ![image-20251218145359830](https://i-blog.csdnimg.cn/img_convert/bdc3a0f32737b2db4dd09067444f4d40.png)

* 示例：

  查看PID=1的信息：`ls /proc/1`

  ![image-20251218145707070](https://i-blog.csdnimg.cn/img_convert/40fa99ecc70c2b3d1801202416600dfe.png)

  

##  ps指令（用户级进程查看工具）

* `ps aux`： 查所有运行的进程（a->所有终端，u->用户中心格式，x->无控制终端进程）

* `ps -l`：查看当前终端进程，详细显示优先级

* `ps ajx | grep 程序名`

  ![image-20251218151222260](https://i-blog.csdnimg.cn/img_convert/5dc129f3b102dc3926fda1c873a9736e.png)

  ![image-20251218151322997](https://i-blog.csdnimg.cn/img_convert/04ec4414791b249b6578555c2a154f27.png)

观察一下这个现象：

![12月18日](https://i-blog.csdnimg.cn/img_convert/2c2869ac14a4d2b6c0e527dc9d82a706.gif)

为什么删除了可执行文件，进程还能运行？

我们删除的是磁盘中的文件，而正在执行的文件已经被加载到了内存，二者不相互影响！如果进程终止，下次就无法继续运行了！

![image-20251218152713791](https://i-blog.csdnimg.cn/img_convert/8e123861afaf13cf34d007eefe96c2ad.png)

## top指令（动态监控进程）

实时刷新进程状态（默认3秒一次），支持修改优先级

操作：

> * 进入top：输入`top`
> * 调整优先级：按`r`->输入进程pid->输入新的nice值
> * 退出：按`q`

pid和nice值后续会详细讲

****



# 4. 如何创建进程（`fork`函数详解）

### 核心功能:

> * 系统调用：`pid_t fork(void);`头文件：`<sys/types.h> <unistd.h>`
> * 功能：创建一个新进程（子进程），父进程和子进程从`fork`之后的代码开始执行

### 两个返回值：->区分父子进程身份

> ![image-20251218182110119](https://i-blog.csdnimg.cn/img_convert/1ce9ed963fefcb4861c4b3756b00f4eb.png)
>
> * 父进程：返回**子进程的pid**->用于识别子进程
> * 子进程：返回**0**，->表示自身是子进程
> * 错误返回：-1->表示资源不足或无法创建子进程
>
> 通过文档我们可以知道，一个父进程可以有多个子进程，但是一个子进程只能有一个父进程，这个很好理解，所以创建子进程成功，用0表示成功即可，而对于父进程，需要子进程的pid进行管理

### 代码共享，数据私有：->验证了进程间有独立性

> * 代码段：父子进程共享一份程序代码（`fork`后执行相同的后续代码）
>
> * 数据段（全局变量、局部变量）：父子进程独立享有数据
>
> * 代码示例：
>
>   ```cpp
>   #include <stdio.h>
>   #include <unistd.h>
>   #include <sys/types.h>
>   
>   // 全局变量（数据段）
>   int global_val = 100;
>   
>   int main(){
>     // 局部变量（栈段）
>     int local_val = 10;
>   
>     // fork前：打印初始值，验证代码执行流程
>     printf("fork前,全局变量: %d, 局部变量：%d\n",global_val, local_val);
>   
>     // 创建子进程
>     pid_t ret = fork();
>     if(ret < 0){
>       perror("fork err");
>     }else if(ret == 0){
>       // 子进程分支，代码共享，执行相同的代码逻辑
>       printf("\n子进程pid:%d, ppid:%d\n",getpid(),getppid());
>       // 子进程修改前
>       printf("子进程修改前：全局变量：%d, 局部变量：%d\n",global_val,local_val);
>   
>       // 子进程修改变量
>       global_val = 500;
>       local_val = 200;
>   
>       // 子进程修改后
>       printf("子进程修改后：全局变量：%d, 局部变量：%d\n",global_val,local_val);
>       sleep(10);
>     }else{
>       // 父进程分支
>       // 父进程sleep休眠 保证子进程完成变量修改
>       sleep(2);
>   
>       printf("\n父进程pid:%d, ppid: %d\n",getpid(),getppid());
>   
>       printf("父进程-子进程修改后：全局变量：%d, 局部变量：%d\n",global_val,local_val);
>       sleep(10);
>     }
>     return 0;
>   }
>   
>   ```
>
>   输出结果：
>
>   ```txt
>   fork前,全局变量: 100, 局部变量：10
>   
>   子进程pid:14567, ppid:14566
>   子进程修改前：全局变量：100, 局部变量：10
>   子进程修改后：全局变量：500, 局部变量：200
>   
>   父进程pid:14566, ppid: 28859
>   父进程-子进程修改后：全局变量：100, 局部变量：10
>   
>   ```
>
>   分析：
>
>   * `pid_t ret = fork();`这行代码的行为：
>     1. 基于当前的父进程，创建子进程，形成子进程的PCB
>     2. **父子进程从`fork`的下一行代码开始，各自独立执行代码**-> 父子进程进入不同的逻辑判断
>     3. 数据层面：初始父子进程同值，修改后各自独立
>
>   **这里再讲一下分支问题：为什么`else if`和`else`这两个逻辑同时执行了？**
>
>   **不是同一个进程同时执行两个分支，而是`fork`创建了两个独立的进程，各自执行不同的分支！！!**
>
>   1. `fork` 调用成功后，内核复制父进程的`task_struct`，创建子进程的 PCB。
>   2. 父进程和子进程同时从`fork()`之后的代码开始运行，但`ret`值不同：
>      * 父进程的`ret`是子进程 PID（正数）→ 进入`else`分支。
>      * 子进程的`ret`是 0 → 进入`else if (ret == 0)`分支。
>   3. 两个进程是独立的执行流，因此看起来 “同时” 进入了不同的分支（本质是并发执行）。

### 补充知识点：详细理解`cwd`

先来看一段代码：

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(){
  FILE* fptr = fopen("new.txt","w");
  if(fptr == NULL){
    perror("fopen err");
  }

  pid_t id = getpid();
  while(1){
    printf("我是一个进程，我的pid: %d\n",id);
    sleep(1);
  }

  return 0;
}

```

如果文件不存在，则会在当前工作目录创建新文件：

![image-20251218193155629](https://i-blog.csdnimg.cn/img_convert/a8db1dea9df42856300386177c0d4f3a.png)

查看cwd：`ls -l /proc/PID/cwd`

![image-20251218193823959](https://i-blog.csdnimg.cn/img_convert/45b948fdc2f72efa5ec18d0c45f50d38.png)

这是代码执行的逻辑：

![image-20251218194349413](https://i-blog.csdnimg.cn/img_convert/5827f6ffc593d49aab24bb8e1f3905ee.png)

exe文件指向进程的详细路径->源可执行文件路径，而每个进程都会记录自己的exe路径和cwd

想要修改cwd，可以利用`chdir`函数，这里不做演示

### 父进程的父进程是谁？

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(){
  pid_t id = fork();

  if(id == 0){
    printf("我是子进程,pid: %d, ppid: %d\n",getpid(),getppid());
  }else{
    printf("我是父进程,pid: %d, ppid: %d\n",getpid(),getppid());
  }

  sleep(1000000);
  return 0;
}

```

![image-20251218200034002](https://i-blog.csdnimg.cn/img_convert/7eb8223729c35b2453f57567e47ca1d2.png)

命令行中，执行命令/执行程序，本质时`bash`的进程创建的子进程，最终由子进程执行我们的代码

### 创建多个进程

```cpp
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main(){
  for(int i = 0; i < 10; i++){
    pid_t id = fork();
    if(id == 0){
      printf("子进程PID: %d,PPID: %d, 序号：%d\n",getpid(),getppid(),i + 1);
      sleep(2);
      return 0; // 子进程退出
    }
  }
    sleep(5); // 让子进程跑完
    printf("父进程:%d,所有子进程创建完毕\n",getpid());

    return 0;
}

```

****



# 5.进程状态

补充知识：

> * **并发：** 多个进程在一个CPU下执行，CPU给每一个进程预分配一个时间片，基于时间片，进行调度轮转执行进程
>
> * **并行：** 多个进程在多个CPU下同时执行
>
> * **时间片：** 在Linux/Windows民用级别的OS时分时操作系统，调度任务追求公平，
>
>   与之对应实时OS，高优先级，比如车载OS，刹车操作时高优先级执行的

## 操作系统学科视角下的进程状态

![image-20251218211956245](https://i-blog.csdnimg.cn/img_convert/a6a12ad2c5989ab5deb7399f90b12ba7.png)

> * 创建态：进程刚被创建，内核正在分配PCB、内存资源，进入就绪队列
> * 就绪态：进程已具备执行条件，等待CPU调度（未占用CPU，但随时能跑，在就绪队列排队）
> * 运行态：进程正在CPU上执行指令（单核CPU同一时间只有1个进程处于这个状态）
> * 阻塞态：进程因为等待某事件（IO完成、资源可用、信号），无法执行，主动放弃CPU（不占用CPU，在等待队列休眠）
> * 终止态：进程执行完毕/被终止，内核正在回收资源，资源回收完成后彻底消失

**阻塞（等待）的本质：**

阻塞（等待）是**进程主动放弃CPU使用权**，核心机制：

当进程需要的事件未就绪：

* 读磁盘但数据未到
* 等待用户输入
* 等待子进程退出

等等情况，继续占用CPU只会浪费CPU资源，阻碍其他进程正常运行

因此，进程从运行/就绪态进入阻塞态，被内核放入对应事件的等待队列，直到事件完成之后，内核将其唤醒至就绪态（不能直接到运行态，如果有其他进程在运行态，直接抢占吗？），重新排队等候CPU调度

## Linux视角下的进程状态

| 状态                 | 缩写 | 全程                  | 对应OS理论         | 核心特征                                                     |
| -------------------- | ---- | --------------------- | ------------------ | ------------------------------------------------------------ |
| 运行/就绪            | R    | Running/Runnable      | 运行态+就绪态      | 要么CPU执行，要么在“运行队列”等待调度（Linux不区分运行/就绪，统一为R） |
| 可中断等待（睡眠）   | S    | Interruptible Sleep   | 阻塞态（可中断）   | 等待事件（`sleep`、键盘输入、`wait`），可被信号（`kill`、`ctrl+c`）唤醒 |
| 不可中断等待（睡眠） | D    | Uninterruptible Sleep | 阻塞态（不可中断） | 等待关键资源（磁盘IO），**不能被信号唤醒** -> 避免数据损坏、丢失 |
| 暂停态               | T    | Stopped               | 特殊阻塞状态       | 被信号（`ctrl+z`、`kill -19`）暂停，可通过`fg/bg`恢复        |
| 僵尸态               | Z    | Zombie                | 终止态（未回收）   | 进程已退出，代码和数据被清理，但PCB仍保留，等待父进程回收处理 |
| 死亡态               | X    | Dead                  | 终止态（已回收）   | 进程资源彻底释放，瞬间状态，`ps`无法捕获                     |

## 进程状态查看

`ps aux / ps axj`

* a：显示一个终端所有的进程，包括其他用户的进程
* x：显示没有控制终端的进程，例如后台运行的进程
* j：显示进程归属的进程组ID、会话ID、父进程ID以及与作业控制相关的信息
* u：以用户为中心的格式显示进程信息，提供用户、CPU和内存使用情况等详细信息

## 代码演示各种状态

### R+S态

```cpp
#include <stdio.h>
#include <unistd.h>

int main(){
  pid_t pid = getpid();
  printf("进程ID: %d\n",pid);
  printf("阶段: R态（死循环，占用CPU）\n");
  /*while(1){
    // 死循环 持续占用CPU
  }
  */
  // 以下代码需要注释掉while循环,演示S态
  
   printf("阶段：S态（sleep 10秒，可中断等待\n");
   sleep(10);
   printf("sleep结束，回到R态\n");

  return 0;

}

```

![image-20251218221545751](https://i-blog.csdnimg.cn/img_convert/beee41015e09cfc03985d0f9aeec43fb.png)

![image-20251218222034112](https://i-blog.csdnimg.cn/img_convert/dcc199d177ef178ac6134ff49ebe258c.png)

S态可被信号唤醒/终止

`+`代表进程在前台执行



### T态（暂停）

```cpp
#include <stdio.h>
#include <unistd.h>

int main(){
  pid_t pid = getpid();
  printf("进程PID:%d\n",pid);
  printf("按ctrl+z暂停进程，变为T态，用fg恢复变为R态\n");

  while(1){
  }

  return 0;
}

```

![image-20251219092650912](https://i-blog.csdnimg.cn/img_convert/a8aad9d3ace67a121d39b5f2cde52599.png)

在我们debug时，进程追踪到断点处停下，此时进程就是T状态

### Z态

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(){
  pid_t child_pid = fork();
  if(child_pid == 0){
    // 子进程：立刻退出，成为僵尸进程
    printf("子进程PID:%d，即将退出\n",getpid());
    return 1;
  }else{
    // 父进程 无限循环 不回收子进程
    printf("父进程PID:%d, 子进程PID:%d\n",getpid(),child_pid);
    printf("子进程成为Z态，请查看状态\n");
    while(1){  }
  }

  return 0;
}
```

![image-20251219094511140](https://i-blog.csdnimg.cn/img_convert/ad7d9b461276c316877f21311e0ffdd7.png)

对于进程退出：代码会不会执行，**释放对应的代码和数据，保留退出信息保存在`task_struct`**，方便用户未来管理

而对于僵尸状态：子进程的`task_struct`由内核维护，方便未来父进程读取退出状态；若是一直没有父进程处理，会一直处于Z态，就会一直消耗内核资源（PCB），大量僵尸进程还会占用PID资源，PID默认上限是32768，导致系统无法创建新进程

### 孤儿进程

父进程先退出，子进程成为孤儿进程，此时谁来管理子进程？->被系统的1号进程领养

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(){
  pid_t ret = fork();

  if(ret == 0){
    printf("子进程PID:%d,PPID:%d\n",getpid(),getppid());
    printf("子进程不退出\n");
    sleep(6);
    while(1){ sleep(15);  }
  }else{
    printf("父进程:%d,父进程即将退出\n",getpid());
    sleep(5);
    return 1;
  }

  return 0;
}

```

输出：

```bash
父进程:4598,父进程即将退出
子进程PID:4599,PPID:4598
子进程不退出
父进程退出
[vect@VM-0-11-centos process]$ 子进程PID:4599,新的PPID:1
```

1号进程的信息：

```bash
[vect@VM-0-11-centos process]$ ps -p 1 -f
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Nov26 ?        00:04:27 /usr/lib/systemd/systemd --switched-root
```

****



# 6. 进程优先级

## 优先级的作用

* 决定进程竞争CPU的先后顺序：优先级越高，越先被调度器选中执行
* 解决竞争性问题：多进程并发时，确保重要的进程优先获得CPU资源

## PRI和nice值

* PRI(Priority)：静态优先级（调度取决于PRI值，越小优先级越高）
* nice：优先级修正值，范围`[-20，19]`
* 计算公式：$PRI(new) = PRI(默认) + nice$ 默认值为80

## 优先级查看与调整

### 查看优先级

`ps -l`

```bash
[vect@VM-0-11-centos ~]$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1002 17266 17265  0  80   0 - 29251 do_wai pts/2    00:00:00 bash
0 R  1002 17371 17266  0  80   0 - 38332 -      pts/2    00:00:00 ps

```

> * UID：执行者的身份，由谁启动的进程
>
>   文件会记录下拥有者、所属组，而所有的操作都是进程操作，进程会记录谁启动的自己，这便对应上了权限控制
>
> * PID：进程的编号
>
> * PPID：父进程的编号
>
> * PRI：优先级，越小越先执行
>
> * NI：nice值，修正PRI

### 修正优先级（不建议修改）

* `nice`命令（创建进程时设置NI）

  `nice -n [ni值] 程序`，例如：`nice -n -5 ./test` → 启动 test 进程，NI=-5，PRI=80-5=75

* `renice`命令（调整已经运行的进程NI）

  `renice [NI值] -p [PID]`，例如：`renice 10 -p 3239` → 把 PID=3239 的进程 NI 设为 10，PRI=80+10=90

* `top`命令（动态调整）

		top → 按`r` → 输入 PID → 输入新 NI 值

****



# 7. 进程切换

## 切换的核心原因

* 时间片耗尽：每个进程都有固定的时间片，用完后必须让出CPU
* 高优先级抢占：新创建的高优先级进程会抢占低优先级进程的CPU
* 进程主动放弃CPU：如进程调用`sleep`进入S态、等待IO

注意：一个进程时间片耗尽时，并不一定执行完，这时也必须退出CPU，等待下一次调度，所以一定要保存上下文数据！！！不然下次接着运行发现没数据就尴尬了

## 切换的本质：进程上下文数据的保存和恢复

* **上下文：** 进程执行时CPU寄存器中的数据
* **切换流程：**
  1. 保存当前进程的上下文（将寄存器里的数据存入进程的`task_struct`）
  2. 从就绪队列中选择下一个要执行的进程
  3. 加载下一个进程的上下文（从下一个进程的`task_struct`读取数据，写入寄存器）
  4. 跳转到下一个进程的程序计数器指向的指令，开始执行

切换的目的是实现并发：单核CPU下，通过快速切换，让多个进程看起来同时执行，人是察觉不到切换的

![image-20251219114339940](https://i-blog.csdnimg.cn/img_convert/0a21c71d7df6aa000a4cd10bb480b4bc.png)

# 8. Linux2.6内核进程$O(1)$调度队列

![image-20251219123540589](https://i-blog.csdnimg.cn/img_convert/8f969f4c77d0a9ca4908f388cc35d339.png)

## 数据结构功能

1. `struct queue` **优先级管理单元**

   是$O(1)$调度的**最小功能单元**，负责管理同一状态（活跃/过期）下的所有优先级进程，三个成员的功能：

   * `nr_active`:记录**当前`queue`里的进程总数**

   * `bitmap[5]`：**优先级标记位图**，每个比特位对应一个进程优先级`[0,139]`,其中`[0,99]`时内核进程优先级，`[100,139]`是用户级别的普通优先级

     为什么设计大小为5？
     * $5 \times 32 = 160 >= 140$，刚好能覆盖
     * 遍历`bitmap`本质是遍历5个整数，每次判断一次整数的32位是否有1(`&0xffff`),最多就遍历五次

   * `queue[140]`：**140个优先级的进程哈希桶**

2. `struct queue array[2]` **双队列容器**

   这是一个 存 2 个`struct queue`的数组，专门用来放**活跃队列**和**过期队列**

   * `array[0]`：默认作为**活跃队列**（存还有剩余时间片的进程）
   * `array[1]`：默认作为**过期队列**（存时间片已经耗尽的进程）

3. `struct runqueue` **CPU就绪队列总管理**

   每个CPU都有一个独立的`runqueue`，它是 调度器的总入口，通过两个指针管理双队列：

   * `struct queue* active`：指向当前的**活跃队列**（调度器只从这个队列里选进程运行）；
   * `struct queue* expired`：指向当前的**过期队列**（暂时不参与调度的进程容器）


## 算法逻辑
### 1. 新进程入队（创建/唤醒）
1. 取进程优先级，如40作为键值
2. 通过哈希映射，键值=桶索引，将进程插入活跃队列的`queue[40]`链表尾部
3. 把活跃队列的`bitmap`中优先级40对应的比特位置1->表示这个优先级有进程
4. 活跃队列`nr_active++`
->全程无遍历，固定映射操作，$O(1)$
### 2. 选进程运行（核心）
1. 遍历活跃队列`bitmap`（最多遍历五次，固定次数），找到第一个为1的比特位->对应系统中最高优先级
2. 按这个比特位对应的优先级，直接定位到`queue[优先级]`链表
3. 取链表头进程，分配CPU运行
->遍历`bitmap`最多五次，后续直接定位，$O(1)$
### 3. 进程时间片耗尽，$O(1)$迁移
1. 从活跃队列的对应优先级桶中移除该进程
2. 若桶为空，将`bitmap`对应比特位置0
3. 把进程插入过期队列的同优先级桶，更新过期队列的`bitmap`和`nr_active`
4. 活跃队列`nr_active--`
->全程无遍历，固定映射操作，$O(1)$
### 4. 活跃队列为空：$O(1)$切换队列
当活跃队列`nr_active==0`时，所有进程时间片耗尽，直接交换`active`和`expired`指针：

* 原来的`active`（指向活跃队列）现在指向过期队列
* 原来的`expired`（指向过期队列）现在指向活跃队列
****

# 9. 命令行参数和环境变量

## 命令行参数：用户显式传递的启动指令

### 底层结构：`argc`+`argv`数组

程序启动时，OS会将命令行参数组织成两个核心参数，传递给`main`函数

* `int argc`：参数个数，**至少为1**，默认参数是程序自身的路径
* `char* argv[]`:参数数组，每个元素是指向参数字符串的指针，最后一个元素为`NULL`


### 核心原理：程序启动时的“数据注入”

在Linux系统里，当用户执行一个程序（如`ls -l -a -n ...`）时，OS会做三件事：

1. 创建进程（分配内核数据结构）
2. 将程序的代码和数据加载到内存中
3. 把**命令行参数**和**环境变量**组成数据结构，如下图

对于`ls -l -a -n ...`这个命令，可以理解为这样的结构

![image-20251220184120313](https://i-blog.csdnimg.cn/img_convert/70236fb6cd4a1685736501dec37a306b.png)

代码1：

```cpp
#include <stdio.h>

int main(int argc, char* argv[]){
  printf("===命令行参数===\n");

  printf("argc: %d\n",argc);

  for(int i = 0; argv[i]; i++){
    printf("argv[%d] = %s\n",i,argv[i]);
  }

  return 0;
}

```

输出结果：

```bash
[vect@VM-0-11-centos environ]$ gcc -std=c99 -o demand demand.c
[vect@VM-0-11-centos environ]$ ./demand
===命令行参数===
argc: 1
argv[0] = ./demand

```

代码2：

```cpp
#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[]){
    // 第一步：检查参数个数，至少需要1个选项参数（argv[1]）
    if (argc < 2) { // 仅输入程序名，未传任何选项
        printf("错误：未传入选项！\n");
        printf("有效选项：-opt1 或 -opt2\n");
        printf("使用示例：./a.out -opt1\n");
        return 1; // 非0返回值表示程序异常退出
    }

    // 第二步：判断argv[1]（唯一的选项参数位置）
    if (strcmp(argv[1], "-opt1") == 0) {
        printf("程序选项1\n");
    } else if (strcmp(argv[1], "-opt2") == 0) {
        printf("程序选项2\n");
    } else {
        printf("错误：无效选项「%s」！\n", argv[1]);
        printf("有效选项：-opt1 或 -opt2\n");
        return 1;
    }

    return 0;
}
```

输出结果：

```bash
[vect@VM-0-11-centos environ]$ gcc -o demand demand.c
[vect@VM-0-11-centos environ]$ ./demand
错误：未传入选项！
有效选项：-opt1 或 -opt2
使用示例：./a.out -opt1
[vect@VM-0-11-centos environ]$ ./demand -opt1
程序选项1
[vect@VM-0-11-centos environ]$ ./demand -opt2
程序选项2
[vect@VM-0-11-centos environ]$ ./demand -op3
错误：无效选项「-op3」！
有效选项：-opt1 或 -opt2
```

### 为什么要设计命令行参数？

**解决程序静态性和运行动态性的矛盾**->让同一个程序，可以根据命令行参数，指定不同的选项，实现不同的功能。就像我们熟悉的`ls`是程序，`-a` `-l`是不同选项，同一个程序用不同的选项实现不同的功能

1. **动态传递配置，无需修改代码**

   命令行参数让程序无需重新编译，通过不同参数实现不同功能

2. **标准化进程启动接口**

   所有程序都通过`argc/argv`接收外部配置，形成统一规范，OS只用按照固定的方式传递参数，不用关心程序内部逻辑->做到OS管理资源，程序专注业务的解耦

3. **支持自动化脚本调用**

   命令行参数可被`Shell`脚本批量传递

再来一段代码：

```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char* argv[]){
  // 无效参数提示
  if(argc < 2){
    printf("当前指令错误！用法：\n");
    printf("选项: -add  -sub  -mul  -div\n");
    printf("示例： ./calculate -add 10 20 -->计算10+20\n");
    return 1;
  }

  if(argc != 4){
    printf("参数个数错误！每个运算需要传入两个数字！\n");
    return 1;
  }

  int num1 = atoi(argv[2]);
  int num2 = atoi(argv[3]);

      if (strcmp(argv[1], "-add") == 0) {
        // 加法：num1 + num2
        printf("%d + %d = %d\n", num1, num2, num1 + num2);
    } else if (strcmp(argv[1], "-sub") == 0) {
        printf("%d - %d = %d\n", num1, num2, num1 - num2);
    } else if (strcmp(argv[1], "-mul") == 0) {
        printf("%d × %d = %d\n", num1, num2, num1 * num2);
    } else if (strcmp(argv[1], "-div") == 0) {
        if (num2 == 0) {
            printf("错误：除数不能为0！\n");
            return 1;
        }
        printf("浮点数结果：%d ÷ %d = %.2f\n", num1, num2, (float)num1 / num2);
    } else {
        // 无效选项提示
        printf("无效选项「%s」！\n", argv[1]);
        printf("支持的选项：-add  -sub  -mul  -div\n");
        return 1;
    }

    return 0;

}

```

输入输出示例：

```bash
[vect@VM-0-11-centos environ]$ ./calculate
当前指令错误！用法：
 -div -add
示例： ./calculate -add 10 20 -->计算10+20
[vect@VM-0-11-centos environ]$ ./calculate -mul 19 21
19 × 21 = 399
[vect@VM-0-11-centos environ]$ ./calculate -div 19 12
浮点数结果：19 ÷ 12 = 1.58

```
## 环境变量

### 什么是环境变量

环境变量是**OS用来指定运行环境的参数**，有三个核心特性：

* **全局性：** 可以被子进程继承（OS在创建子进程时，会自动拷贝父进程的环境表）
* **继承边界性：** 子进程修改环境变量，不会影响父进程的环境表
* **配置统一：** 帮助程序解决“找不到依赖”的问题（如编译器找动态库、Shell找命令路径），避免每个进程重复匹配

举个例子：

写的一个C程序编译生成`a.out`，运行时需要链接`glibc`库。不用告诉程序`glibc`在哪里——OS 会通过环境变量提前配置好库的搜索路径，程序启动时OS会自动读取环境变量，帮程序找到依赖库

### 常见的环境变量

| 环境变量 | 作用                                                         | 例子                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `PATH`   | 指定「命令搜索路径」：OS 执行命令时，会遍历`PATH`中的目录找可执行文件 | 为什么`ls`能直接运行？因为`/bin/ls`在`PATH`中；而自己写的`a.out`需要`./a.out`（带路径），因为它不在`PATH`中 |
| `HOME`   | 指定用户家目录：OS 为不同用户（root / 普通用户）分配独立工作空间，统一默认路径 | root 用户`echo $HOME`输出`/root`，普通用户输出`/home/xxx`；`cd ~`本质是进入`HOME`指定的目录 |
| `SHELL`  | 指定当前终端的解释器：OS 为用户提供统一的命令交互接口        | 通常值为`/bin/bash`，表示 OS 使用 bash 作为默认 Shell，所有命令输入都由 bash 解析后交给 OS 执行 |

### 环境变量的使用：OS提供的操作接口

OS提供了命令行工具和系统调用，让用户/程序能直接操作它

**用户级接口**

> * `echo $NAME`：查看某个环境变量值
>
>   ```bash
>   [vect@VM-0-11-centos ~]$ echo $PATH
>   /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/vect/.local/bin:/home/vect/bin
>   ```
>
> * `export NAME=value`： 新增/修改环境变量
>
>   ![image-20251220215341215](https://i-blog.csdnimg.cn/img_convert/c6150dd75219b341d09cef06103e1af8.png)
>
>   解析一下：`hello`所在的当前目录`./`不在PATH中，OS找不到，添加之后，OS便能在PATH中找到`hello`->这就是`ls`直接能运行的原理！
>
> * `env`：查看所有环境变量
>
>   ![image-20251220215859743](https://i-blog.csdnimg.cn/img_convert/221808261b9b6a9218b5b7a63d811e1c.png)
>
>   截取了几个关键的环境变量，这个显式格式是`KEY=VALUE`键值对模型，所以**环境变量是以键值对形式存储的**！
>
> * `unset NAME`：清除环境变量
>
> * `set`：查看本地Shell变量+环境变量：包含`env`的输出并多了Shell的本地临时变量

我们再来看两个例子：
先铺垫知识：
Shell是一个**独立的进程**，在终端输入的所有指令，本质是让Shell进程执行对应操作：
* Shell进程的内存里有两个变量存储区域：
	* **本地变量区：** 只有Shell自己能访问，不传给子进程
	* **环境变量区：** 会被完成拷贝给Shell创建的所有子进程
* `gectenv()`函数**只遍历进程的环境变量区**，不会访问本地变量区

```cpp
#include <stdio.h>
#include <stdlib.h>

int main(){
  char* env = getenv("MYENV");

  if(env == NULL){
    printf("未找到\n");
  }else{
    printf("成功读取MYENV：%s\n",env);
  }

  return 0;
}
```

```bash
[vect@VM-0-11-centos environ]$ MYENV="hello"
[vect@VM-0-11-centos environ]$ vim find_myenv.c
[vect@VM-0-11-centos environ]$ gcc -o find_myenv find_myenv.c
[vect@VM-0-11-centos environ]$ ./find_myenv
未找到
```

分析：

> 1. `MYENV="hello"`：把 `MYENV="hello"`存入本地变量区，**环境变量区没有这个变量**
> 2. 运行`./find_myenv`：OS创建子进程执行程序，OS复制Shell的环境表给子进程（不拷贝本地变量区），程序调用`getenv("MYENV")`，遍历子进程的环境表，找不到对应数据

```bash
[vect@VM-0-11-centos environ]$ export MYENV="hello"
[vect@VM-0-11-centos environ]$ ./find_myenv
成功读取MYENV：hello

```

分析：

>1. `export MYENV="hello"`：OS将`MYENV`写入环境变量区中
>2. 运行`./find_myenv`：OS创建子进程执行程序，OS复制Shell的环境表给子进程（有`MYENV`），程序调用`getenv("MYENV")`，遍历子进程的环境表，找到对应数据

总结：**环境变量是进程的全局配置，OS 在创建子进程时，会复制父进程的 PCB、内存空间，同时也复制环境表**—— 保证子进程继承父进程的运行环境，无需重新配置



### 操作环境变量：OS提供的系统调用接口

#### 命令行第三个参数`env[]`

OS在启动进程时，会将环境变量表作为第三个参数传给`main`

```cpp
#include <stdio.h>
#include <stdlib.h> 

int main(int argc, char* argv[], char* env[]){
  for(int i = 0; env[i]; i++){
    printf("%s\n",env[i]);
  }
  return 0;
}

```

#### 全局变量`environ`

OS在`libc`中提供了全局变量`environ`，直接指向环境变量表（不用传递参数）

```cpp
#include <stdio.h>

extern char** environ;    // 不在头文件中，需要提前声明
int main(){
  for(int i = 0; environ[i]; i++){
    printf("%s\n",environ[i]);
  }
  return 0;
}

```

#### 系统调用`getenv/putenv`

```cpp
int main(){
  char* path = getenv("PATH");
  printf("PATH:%s\n",path);

  putenv("MYENV=hhhh"); // 设置环境变量
  
  return 0;
}

```
### 补充：main函数的参数
`main`函数的`argc/argv`由谁传递？
程序启动，内核创建进程，分配PCB，加载代码数据，由`libc`的启动函数`_start`解析命令行参数/环境变量，组装成`argc/argv/env`，最后调用`main`
****



# 10. 进程地址空间

## 程序地址空间

先来看一个有趣的现象：

```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int global = 10;
int main(){
  pid_t ret = fork();
  if(ret < 0){
    perror("fork err\n");
    return 1;
  }else if(ret == 0){
    // 子进程
    while(1){
      printf("I am child process,pid:%d,ppid:%d,global:%d,global pos:%p\n",getpid(),getppid(),global, &global);
      ++global;
      sleep(1);
    }
  }else{
    // 父进程
    while(1){
       printf("I am father process,pid:%d,ppid:%d,global:%d,global pos:%p\n",getpid(),getppid(),global, &global);
       sleep(5);
    } 
  }
  return 0;
}

```

输出：![image-20251221165111755](https://i-blog.csdnimg.cn/img_convert/0773e13cf73af258750be6b2e7bdb96e.png)

父进程和子进程的数据是各自独立，代码是共享的，这个我们已经了解，但是**为什么`global`的地址一直没有变化？**

我们根据输出内容可以推断出：

> * 输出的内容不一样，所以父子进程输出的变量绝对不是同一个变量！
> * 不同的变量却有相同的地址，说明这个地址一定是虚拟的！

其实，**用户层面看不到真实的物理地址，我们能看到的只有虚拟地址！！！**

实际的物理地址是由OS统一管理的，OS系统把虚拟地址转化成物理地址

![image-20251221183939848](https://i-blog.csdnimg.cn/img_convert/bb3ac56f1af709fcc77cc9a700f7d051.png)



再来回忆一下以前的程序内存布局图：

![image-20251221171247319](https://i-blog.csdnimg.cn/img_convert/f8007e61b6a0ad004a42c9b3b16e797a.png)

代码验证：

```cpp
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int global_val = 10;
int g_val;
int main(int argc, char* argv[], char* env[]){
  const char* str = "hello";
  printf("code addr: %p\n",main);
  printf("init global_val addr: %p\n",&global_val);
  printf("uninit g_val addr: %p\n",&g_val);
   
  static int test_val = 1;
  char* heap_mem1 = (char*)malloc(10);  
  char* heap_mem2 = (char*)malloc(10);
  char* heap_mem3 = (char*)malloc(10);
  printf("haep addr: %p\n",heap_mem1);
  printf("haep addr: %p\n",heap_mem2);
  printf("haep addr: %p\n",heap_mem3);

  printf("test_val static addr: %p\n",&test_val);

  printf("stack addr: %p\n",&heap_mem1);
  printf("stack addr: %p\n",&heap_mem2);
  printf("stack addr: %p\n",&heap_mem3);

  printf("read only string add: %p\n",str);
  for(int i = 0; i < argc; i++){
    printf("argv[%d]: %p\n",i,argv[i]);
  }
  for(int i = 0; env[i]; i++){
    printf("env[%d]: %p\n",i, env[i]);
  }

  return 0;
}

```

![image-20251221173549702](https://i-blog.csdnimg.cn/img_convert/a4202ded1c38e86208b37b0e2385ea41.png)

## 进程地址空间

所以以前所说的程序的地址空间是有些问题的，确切地说是**进程地址空间**，那张内存布局图应该叫进程地址空间

进程空间地址本质是**内核数据结构对象（类似PCB）**，在Linux中由结构体`mm_struct`实现

如何理解进程地址空间呢？

> 进程地址空间类似与一把尺子，尺子的刻度由`0x00000000`到`0xffffffff`，按照刻度被划分为各个区域->代码区、堆区、栈区等等
>
> 在`mm_struct`中，记录了各个边界刻度，如下图所示：
>
> ![image-20251221185044287](https://i-blog.csdnimg.cn/img_convert/e6dbbd1fe0ff621c4e0da1c9dc745130.png)
>
> 怎么完成区域划分呢？类比”38线“->一条线划分出两个区间，我们知道区间的起始值和结束值，便可划分出一个区域！

在`mm_struct`中，每个刻度都代表一个虚拟地址，这些虚拟地址通过页表映射与物理内存建立联系。由于地址是从`0x00000000`到`0xffffffff`线性增长的，所以虚拟地址又叫做线性地址

所以：

> * 堆向上增长以及栈向下增长实际就是改变`mm_struct`中栈和堆的边界数值->好比改变“38线”的位置，两个人的所占空间就改变！
> * 我们生成的可执行程序实际上也被划分为了各个区域，例如**初始化区域，未初始化区域、代码段、只读数据段**。当可执行程序运行起来，OS则将对应的数据加载到对应内存中即可，大大提高了OS的操作效率，而进行可执行程序的分区操作，实际上是编译器的操作，我们所说的代码优化级别实际上是编译器掌握的

每个进程被创建时，对应的`task_struct`和`mm_struct`也会被创建。OS可以通过进程的`task_struct`找到`mm_struct`，因为`task_struct`中有一个结构体指针存的是`mm_struct`的地址

![image-20251221190327662](https://i-blog.csdnimg.cn/img_convert/17ba2bc253d9cd5c50dbb9407c0635e7.png)

例如：父进程有自己的`task_struct`和`mm_struct`，该父进程创建的子进程也有自己的`task_struct`和`mm_struct`，父子进程的`mm_struct`当中的各个虚拟地址分别通过页表映射到物理空间的具体位置，如下图：

![image-20251221193910354](https://i-blog.csdnimg.cn/img_convert/d70a63f7cd4e0bca95eed283b94cf0d0.png)

当子进程被创建时，子进程和父进程的，代码和数据是共享的，即父子进程的代码和数据通过页表映射到物理内存的同一块空间。只有当父进程或子进程需要修改数据的时候，才将进程的数据在内存中拷贝一份，然后进行修改

例如，子进程修改`global_val`的值，触发写时拷贝，内核重新分配物理内存，拷贝数据，修改子进程页表的物理地址映射关系，虚拟地址始终不变

![image-20251221193736132](https://i-blog.csdnimg.cn/img_convert/134056c12b43685a8e989e29ddeb113d.png)

这种方式叫做**写时拷贝**

**为什么要写时拷贝？**

> 进程间具有独立性。多进程运行，需要独享资源，确保多进程运行期间互不干扰，子进程的修改不能干扰父进程

**为什么不在创建子进程时就拷贝数据？**

> 子进程不一定会使用父进程的所有数据，并且子进程不对数据写入的情况下，没有必要对数据进行拷贝，按需分配即可，这样可以高效利用空间

## 总结几个问题

### 程序加载到内存中的过程

 1. 内核创建PCB和`mm_struct`(虚拟地址空间）
 2. 初始化`mm_struct`：按可执行程序的编译分区->.text/.data/.bss/.rodata划定范围
 3. 加载程序：
	* .text/.data/.bss/.rodata：分配物理内存，建立页表映射，同时把./rodata设为只读
	* 栈区：分配物理内存，加载命令行参数/环境变量到栈顶
	* 堆区：划定虚拟地址范围，不分配物理内存
4. 设置页表寄存器指向进程页表，CPU跳转到代码入口`_start`执行

### 为什么需要虚拟地址和页表？

1. 进程隔离：每个进程独立页表，虚拟地址相同但物理地址不同，保证进程独立性；
2. 内存保护：页表的rwx标记位，拦截非法访问（如写只读页、访问内核内存）；
3. 高效利用内存：按需分页（缺页异常时分配物理页）+ 写时拷贝（fork不立即拷贝数据），减少内存浪费；
4. 解耦进程和内存管理：进程只关心虚拟地址，内存只关心物理地址，OS统一管理映射。

### `malloc`分配堆空间是分配物理内存吗？
不是，`malloc`只做两件事：
* 修改`mm_struct`堆区边界值，分配虚拟地址
* 首次访问堆区虚拟地址时，触发缺页异常，内核才分配物理内存建立页表映射

### 进程退出后，`malloc`未`free`内存会泄露吗？
分场景：
1. 用户态内存：OS会回收进程的`mm_struct`、页表，所有映射的物理空间标记为空，不会泄漏
2. 内核态内存：进程申请了内核内存但未释放，会导致内核内存泄漏，OS不会自动回收内核内存

 ### **什么是野指针？**

野指针分两种场景：
  ①指向已释放的虚拟地址（页表映射已删除）→ 触发缺页异常，内核判定为非法访问，发送信号终止进程；
 ②指向未分配的虚拟地址（无页表映射）→ 同样触发缺页异常并终止进程

### **为什么`char* str = "hh"; *str = 'H';`能编译通过，但运行时崩了？**
* 编译层：`hh`存于.rodata段，只读，未加`const`编译通过
* 运行层：.rodata段的页表被标记为只读，写操作触发缺页异常
* 内核层：发送信号，进程崩溃（段错误）

### 全局变量、字符常量为什么有常性？

 在虚拟地址空间中，全局变量存在未初始化区、字符常量存在只读字段区，随着进程一直存在，他们的地址能被所有类和函数看到
